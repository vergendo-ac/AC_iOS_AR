//
//  HalfRealTimeSceneInteractor.swift
//  YaPlace
//
//  Created by Rustam Shigapov on 11/09/2019.
//  Copyright (c) 2019 SKZ. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreLocation.CLLocation
import ARKit

typealias StickerViewDistance = (sticker: StickerSceneView, distance: Double)

public protocol StickerDelegate {
    func tapped(stickerID: Int, stickerData: StickerModels.StickerData?)
    func update(stickers: [StickerModels.StickerData])
}

protocol HalfRealTimeSceneBusinessLogic {
    
    func savePhoto(request: HalfRealTimeScene.SavePhoto.Request)
    
    func takeNextPhoto(request: HalfRealTimeScene.TakeNextPhoto.Request)
    
    func start(request: HalfRealTimeScene.Start.Request)
    
    func justSavePhoto(request: HalfRealTimeScene.JustSavePhoto.Request)
    
    func show2DMarkers(request: HalfRealTimeScene.Nodes.Request)
    func move2DMarkers(request: HalfRealTimeScene.Markers2DMovable.Request)
    
    func makeSettings(request: HalfRealTimeScene.Settings.Request)
    func doDeInit(request: HalfRealTimeScene.DeInit.Request)
    
    func restartArSession()
    
    func arCameraUpdateLocation(request: HalfRealTimeScene.UpdateLocation.Request)
    func arCameraUpdateDeviceMotion(request: HalfRealTimeScene.UpdateDeviceMotion.Request)
    func updateArTrackingState(request: HalfRealTimeScene.ArTrackingState.Request)
    
    func updateArTrace(request: HalfRealTimeScene.ArTrace.Request)
    func setupArCreature(request: HalfRealTimeScene.ArCreature.Request)
    func startArCameraManager(request: HalfRealTimeScene.StartArCamera.Request)
    
    func handleAnchors(request: HalfRealTimeScene.HandleAnchors.Request)
    func createAnchor(request: HalfRealTimeScene.AnchorAction.Request)
    func updateAnchor(request: HalfRealTimeScene.AnchorAction.Request)
    func rebaseToLastAnchor(request: HalfRealTimeScene.MainNode.Request)
    
    func handleVideoSticker(request: HalfRealTimeScene.VideoSticker.Request)
    func clearArContent(request: HalfRealTimeScene.ClearArContent.Request)
    func removeArContent(request: HalfRealTimeScene.ClearArContent.Request)
    
    func kfsFrameSelector(request: HalfRealTimeScene.FrameSelector.Request)
    func kfsClearParams()
    
    func localize(request: HalfRealTimeScene.Localize.Request)
    
    func getLocalizeData(request: HalfRealTimeScene.LocalizeData.Request)
    func showARObjects(request: HalfRealTimeScene.ARObjects.Request)
    
    func setDelegate(request: HalfRealTimeScene.Delegate.Request)
    func delete(request: HalfRealTimeScene.Delete.Request)
}

protocol HalfRealTimeSceneDataStore {
    var currentImage: ImageModels.Image? { get set }
    var stickers: [Int: StickerModels.StickerData]? { get set }
    var stickerClusterViewCompletion: (Int, StickerModels.StickerData?) -> () { get set }
    var stickerMarkerFrameViewCompletion: (Int) -> () { get set }
    var currentStickerData: StickerModels.StickerData? { get set }
    var currentOpenViewsNum: Int { get set }
    
    var stickerSubviewYPositionUpdate: (CGFloat?) -> () { get set }
    
    var hasSensors: Bool { get set}
    
    var stopKFS: Bool { get set }

}

class HalfRealTimeSceneInteractor: HalfRealTimeSceneDataStore {
    var presenter: HalfRealTimeScenePresentationLogic?
    var worker: HalfRealTimeSceneWorker?
    
    /// A serial queue for thread safety when modifying the SceneKit node graph.
    let updateQueue = DispatchQueue(label: Bundle.main.bundleIdentifier! +
        ".serialSceneKitQueue")
    let contentQueue = DispatchQueue(label: "\(Bundle.main.bundleIdentifier!).contentQueue", qos: .userInteractive)
    
    // HalfRealTimeSceneDataStore
    var currentImage: ImageModels.Image? {
        willSet {
            print("currentImage didSet == nil -> ", newValue == nil)
        }
    }
    var stickers: [Int: StickerModels.StickerData]?
    var stickerClusterViewCompletion: (Int, StickerModels.StickerData?) -> Swift.Void = {_,_  in }
    var stickerMarkerFrameViewCompletion: (Int) -> Swift.Void = {_ in }
    var currentStickerData: StickerModels.StickerData?
    var currentOpenViewsNum: Int = 0
    var stickerSubviewYPositionUpdate: (CGFloat?) -> Swift.Void = {_ in }
    weak var uiNavigationController: UINavigationController?
    var pinView: UIView?//PassthroughView?
    var hasSensors: Bool = false
    var stopKFS: Bool = true
    
    // arSession degradation parameters
    private var lastLocation: CLLocation?
    private var lastCameraPosition: simd_float3?
    private var lastMeasure: AccMeasure?
    private var countMeasures = 0
    private var degradationLimit: Float {
        return UserDefaults.restartArsLimitValue ?? 0
    }
    
    //REPLACE - MarkerSceneView
    var stickerSceneViews: [Int: StickerSceneView] = [:]
    var currentStickerId: Int = -1
    var currentLocation: CLLocation? = nil
    
    //local variables
    var testSticker2D: Bool = false // Bool sticker variable
    var windowSize: CGSize = .zero
    private var isCameraStopped: Bool = false
    var currentDeviceOrientation: UIDeviceOrientation? = .portrait
    var errorsInARowLimit = 10
    private var stickerMarkerFrameViews: [Int: StickerMarkerFrameSceneView]? = nil
    private var moveMarkerCounter = 0
    //MARK: Nodes num by sides
    private var leftPointsNum: Int?
    private var centralPointsNum: Int?
    private var rightPointsNum: Int?
    
    private var stickersShown: Bool = false
    private var stickerDelegate: StickerDelegate?
    
    private var arTraceManager = ArTraceManager.sharedInstance
    private var arCreatureManager = ArCreatureManager.sharedInstance
    private var arPinMaxDistance = UserDefaults.arPinMaxDistanceValue ?? 200
    private var arStickerDistanceEnabled = UserDefaults.arStickerDistanceEnabled ?? false
    private var stickersLimit = 5
    private var lastMainNodePoses: Node3dPoses?
    private var currentCategoryPin: CategoryPin?
    private var prevNearObjectsPins: ScreenNearObjectsPins = (.none, .none)
    private var lastVideoNodes: [String: ARFVideoNode] = [:]
    
    //MARK: Clusters
    private let clusterCoordBinOffset: Int = 5 // 2ˆ5
    private let clusterCellSize: Int = 32 // 2ˆ5
    private var clusters: [Int: StickerSceneView] = [:]
    private var clusterizator: [[Int]] = []
    private var defaultClusterizator: [[Int]] = []
    
    //MARK: Localize
    private var localizeAttempts: Int = 0
    private let localizeAttemptsLimit: Int = 30
    private var localizeIsFirstAttempt: Bool = true
    private var localizeTimer: Timer?
    private var localizeDataCompletion: ((_ imageData: Data?, _ location: CLLocation?, _ photoInfo: [String:Any]?, _ cameraPose: Pose) -> Void)?
    
    var errorsInARow: Int = 0 {
        didSet {
            print("errorsInARow = \(errorsInARow)")
        }
    }
    
    private func doPhotoResponse(maybeResponse: NetModels.Response2D?) {
        if let response = maybeResponse {
            self.errorsInARow = 0
            if let nodes = response.nodes, let stickers = response.stickers {
                self.calcStickerNodes(maybeNodes: nodes, maybeStickers: stickers) {
                    self.showStickerNodes()
                }
            } else {
                self.doClear2DMarkers()
            }
        }
    }
    
    private func showStickerNodes() {
        self.stickersShown = true
        self.doPresentNodes()
    }
    
    private func calcStickerNodes(maybeNodes: [StickerModels.Node]?, maybeStickers: [StickerModels.StickerData]?, completion: (() -> Void)? = nil) {
        var maybeStickerNodes: [StickerModels.StickerNode]? = nil
        var maybeStickerFrames: [Int:PointModels.DistantFramePoints]? = nil
        
        self.stickersShown = false

//        self.stickerMarkerViews.removeAll()
//        self.stickerMarkerFrameViews?.removeAll()
        
        //MARK: Calc stickers & frames points
        if let imageSize = self.currentImage?.size, let nodes = maybeNodes, let stickers = maybeStickers, nodes.count == stickers.count,
            let triplePoints = self.worker?.calcNodesTriplePoints(maybeNodes: nodes, imageSize: imageSize, windowSize: self.pinView?.frame.size ?? self.windowSize, maybeDeviceOrientation: self.currentDeviceOrientation),
            let framePoints = triplePoints.framePoints {
            
            stickerDelegate?.update(stickers: stickers)
            
            //save all stickers as key-value pairs
            self.stickers = (stickers.reduce(into: (-1, [:]), { (acc, sticker) in
                acc.0 = sticker.id!
                acc.1[sticker.id!] = sticker
            })).1
            
            let calcNodesFrames: ([Int:PointModels.DistantPoint]?) -> Void = { [weak self] points in
                if let points = points {
                    maybeStickerNodes = self?.worker?.makeStickerNodes(points: points, maybeStickers: self?.stickers)
                    maybeStickerFrames = framePoints.filter({ (key, _) -> Bool in
                        points.keys.contains(key)
                    })
                }
            }
            
            if let arCameraEnabled = UserDefaults.arCameraEnabled {
                calcNodesFrames((arCameraEnabled) ? triplePoints.allPoints : triplePoints.centralPoints)
            } else {
                calcNodesFrames(triplePoints.centralPoints)
            }

            leftPointsNum = triplePoints.leftPoints?.count
            centralPointsNum = triplePoints.centralPoints?.count
            rightPointsNum = triplePoints.rightPoints?.count
            
        } else {
            print("HalfRealTimeSceneInteractor: doStickerNodes: \((maybeNodes?.count) ?? 0) =? \((maybeStickers?.count) ?? 0)")
        }
        
        //MARK: Build stickers
        if let stickerNodes = maybeStickerNodes {
            let isAR = (UserDefaults.arCameraEnabled ?? false)
            let isARFun = (UserDefaults.arFun ?? false)
            let isARObjectsEnabled = (UserDefaults.arObjectsEnabled ?? false)
            let weHave3DSticker = (UserDefaults.current3DSticker != nil && UserDefaults.current3DSticker! != Sticker3DHelper.Sticker3DSourceType.none.name)
            let hideStickerMarker: Bool = isAR && isARFun && isARObjectsEnabled && weHave3DSticker
            
            self.stickerSceneViews = stickerNodes.reduce(into: [:], { (acc, stickerNode) in
                acc[stickerNode.id] = StickerSceneView(
                  stickerId: stickerNode.id,
                  stickerDistancePoint: stickerNode.distantPoint,
                  stickerData: stickerNode.stickerData,
                  hideStickerMarker: hideStickerMarker,
                  pinView: pinView ?? PassthroughView(),
                  stickerMarkerViewCompletion: { [weak self] (id, data) in
                    self?.stickerDelegate?.tapped(stickerID: id, stickerData: data)
                  }
                )
                acc[stickerNode.id]?.isHidden = true
            })
        }

        //MARK: Build frames
        
        if (UserDefaults.showStickerFrameMode ?? false), let stickerFrames = maybeStickerFrames {
            self.stickerMarkerFrameViews = stickerFrames.reduce(into: [:], { (acc, stickerFrame) in
                let (key, stickerFramePoints) = stickerFrame
                acc?[key] = StickerMarkerFrameSceneView.init(
                    index: key,
                    stickerDistantFramePoints: stickerFramePoints,
                    stickerMarkerFrameViewCompletion: self.stickerMarkerFrameViewCompletion
                )
            })
        } else {
            self.stickerMarkerFrameViews = nil
        }
        
        //self.stickerMarkerFrameViews = nil
        completion?()
        
    }
    
    //TODO: - updateStickersPosition
    private func doPresentNodes() {
        print(self.stickerSceneViews.count)
        //let chessedView = worker?.chessStickers(views: self.stickerMarkerViews.values.reduce(into: [], { $0.append($1) }))
        //let positionViews = worker?.updateStickersPosition(views: stickerMarkerViews.values.reduce(into: [], { $0.append($1) }), pinViewSize: pinView?.frame.size ?? windowSize)
        let positionViews = worker?.alignStickers(views: stickerSceneViews.values.reduce(into: [], { $0.append($1) }), pinViewSize: pinView?.frame.size ?? windowSize)
        let response = HalfRealTimeScene.Nodes.Response (
            views: Array(stickerSceneViews.values),
            frames: self.stickerMarkerFrameViews?.values.reduce(into: [], { $0.append($1) })
        )
        self.presenter?.presentNodes(response: response)
    }
    
    private func doNextPhoto(request: HalfRealTimeScene.TakeNextPhoto.Request) {
        if self.errorsInARow < self.errorsInARowLimit, !self.isCameraStopped {
            let response = HalfRealTimeScene.TakeNextPhoto.Response(completion: request.completion)
            presenter?.presentTakeNextPhoto(response: response)
        }
    }
    
    private func doClear2DMarkers() {
        self.stickers?.removeAll()
        self.stickerSceneViews.removeAll()
        self.stickerMarkerFrameViews?.removeAll()
        
        self.doPresentNodes()
    }
    
    private func parse2DTest() {
        worker?.parse2DTest(completion: { [weak self] (response, status) in
            guard let self = self else { return }
            if !self.isCameraStopped {
                self.doPhotoResponse(maybeResponse: response)
            }
        })
    }
    
    private func makeClusters(stickers: [StickerSceneView]) {
        //Clear clusters
        self.clusterizator = self.defaultClusterizator
        self.clusters = [:]
        
        //Collect clusters
        stickers.forEach {
            let newX = Int($0.stickerCentralPoint.x) >> self.clusterCoordBinOffset
            let newY = Int($0.stickerCentralPoint.y) >> self.clusterCoordBinOffset
            let index = newY * newX + newX
            self.clusterizator[index].append($0.stickerId)
        }
        
        //Make cluster central point
        //TODO: central distance
        let prepareCentralPoint: (Int, [Int]) -> (Int, CGPoint) = { index, arrStickerIndex in
            let centralPoints: [CGPoint] = arrStickerIndex.compactMap {
                self.stickerSceneViews[$0]?.isHidden = true
                return self.stickerSceneViews[$0]?.stickerCentralPoint
            }
            let centralPoint: (CGFloat, CGFloat) = centralPoints.reduce(into: (0, 0), { $0 = ($0.0 + $1.x, $0.1 + $1.y) })
            return (index, CGPoint(x: centralPoint.0 / CGFloat(centralPoints.count), y: centralPoint.1 / CGFloat(centralPoints.count)))
        }
        
        let clusterID = UUID().hashValue
        self.clusterizator.enumerated().filter { $1.count > 1 }.map { prepareCentralPoint($0, $1) }.forEach { (index, cP) in
            let clusterView = StickerSceneView(
                stickerId: index,
                stickerDistancePoint: PointModels.DistantPoint(1.0, cP), //TODO: distance!
                stickerData: nil,
                hideStickerMarker: true,
                pinView: self.pinView ?? PassthroughView(),
                stickerMarkerViewCompletion: { _,_ in } //self.stickerClusterViewCompletion
            )
            clusterView.set(tag: .StickerMarkerClusterView)
            clusterView.viewType = .cluster //show cluster picture
            self.clusters[clusterID] = clusterView
        }
        
        print(self.clusters.count)
        
        //Show clusters
        let response = HalfRealTimeScene.Clusters.Response(clusters: Array(self.clusters.values))
        presenter?.presentClusters(response: response)
    }
    
}

extension HalfRealTimeSceneInteractor: HalfRealTimeSceneBusinessLogic {
    
    func kfsClearParams() {
        self.stopKFS = false
    }
    
    func startArCameraManager(request: HalfRealTimeScene.StartArCamera.Request) {
        arPinMaxDistance = UserDefaults.arPinMaxDistanceValue ?? 200
        arStickerDistanceEnabled = UserDefaults.arStickerDistanceEnabled ?? false
    }
    
    func doDeInit(request: HalfRealTimeScene.DeInit.Request) {
        self.currentImage = nil
        self.stickers = nil
        self.stickerClusterViewCompletion = {_,_  in }
        self.currentStickerData = nil
        self.currentOpenViewsNum = 0
        self.uiNavigationController = nil
        self.stickerSceneViews = [:]

        let response = HalfRealTimeScene.DeInit.Response()
        //presenter?.presentDeInit(response: response) 
        
        self.presenter = nil
        self.worker = nil
    }
    
    func restartArSession() {
        self.localizeIsFirstAttempt = true
        self.localizeAttempts = 0
        
        let response = HalfRealTimeScene.ArSessionRun.Response(options: [.resetTracking])
        presenter?.presentArSessionRun(response: response)
    }
    
    private func countAccDegradationFactor(position: simd_float3, location: CLLocation? = nil) -> (factor: HalfRealTimeScene.DegradationFactor, distanceType: HalfRealTimeScene.DistanceType)? {
        
        guard degradationLimit > 0 else {
            return nil
        }
        
        if let lastPosition = self.lastCameraPosition, let measure = self.lastMeasure {
            let arkitX = (lastPosition - position).norma()
            var distance = max(0.1, Float(measure.x.norma()))
            var distanceType: HalfRealTimeScene.DistanceType = .acc
            
            if let updateLocation = location, let lastLocatiom = self.lastLocation {
                let d = Float(lastLocatiom.distance(from: updateLocation))
                
                if d >= 1 && d > Float(updateLocation.horizontalAccuracy)/2 {
                    distance = d
                    distanceType = .gps
                }
            }
            
            if distance > 0 {
                let f = arkitX/distance
                
                if f > self.degradationLimit {
                    return (HalfRealTimeScene.DegradationFactor.degradated(factor: f), distanceType)
                } else {
                    return (HalfRealTimeScene.DegradationFactor.normal(factor: f), distanceType)
                }
            }
        }
        return nil
    }
    
    func arCameraUpdateLocation(request: HalfRealTimeScene.UpdateLocation.Request) {
        DispatchQueue.main.async() {
            
            if let result = self.countAccDegradationFactor(position: request.cameraPosition, location: request.location) {
                
                switch result.factor {
                    case .degradated:
                        self.kfsClearParams()
                        self.restartArSession()
                    default:
                        break
                }
                
                let response = HalfRealTimeScene.ArSessionStatus.Response(factor: result.factor, disatnceType: result.distanceType, trackingState: request.trackingState, state: request.state)
                self.presenter?.presentArSessionStatus(response: response)
            }
            
            self.lastCameraPosition = request.cameraPosition
            self.lastLocation = request.location
            self.lastMeasure = nil
            self.countMeasures = 0
        }
    }
    
    func arCameraUpdateDeviceMotion(request: HalfRealTimeScene.UpdateDeviceMotion.Request) {
        
        let a = request.deviceMotion.userAcceleration
        let f = 0.993
        let G = 9.81

        guard let prev = lastMeasure else {
            lastMeasure = AccMeasure(simd_double3(a.x, a.y, 0))
            return
        }

        let curr = AccMeasure(simd_double3(a.x, a.y, 0))
        let dt = curr.t - prev.t

        curr.v = f*prev.v + G*(dt/2)*(curr.a + prev.a)
        curr.x = prev.x + dt*curr.v

        lastMeasure = curr
        countMeasures += 1

        if countMeasures > 0, countMeasures % 100 == 0,
            let result = countAccDegradationFactor(position: request.cameraPosition) {
            
            print("[lock] check factor:\(result.factor), count:\(countMeasures)")
            
            switch result.factor {
                case .degradated:
                    self.kfsClearParams()
                    self.restartArSession()
                    let response = HalfRealTimeScene.ArSessionStatus.Response(factor: result.factor, disatnceType: result.distanceType, trackingState: request.trackingState, state: request.state)
                    self.presenter?.presentArSessionStatus(response: response)
                
                    self.lastLocation = nil
                    self.lastMeasure = nil
                    self.countMeasures = 0
                default:
                    break
            }
        }
    }
    
    func updateArTrackingState(request: HalfRealTimeScene.ArTrackingState.Request) {
        let response = HalfRealTimeScene.ArTrackingState.Response(trackingState: request.trackingState, state: request.state)
        presenter?.presentArTrackingState(response: response)
    }
    
    func savePhoto(request: HalfRealTimeScene.SavePhoto.Request) {
        self.currentDeviceOrientation = request.deviceOrientation
        self.currentLocation = request.currentLocation ?? self.currentLocation
        guard let worker = self.worker else {
            print("HalfRealTimeSceneInteractor: No worker")
            return
        }
        //        if let data = request.image?.data {
        //            //print(data.getMetaData())
        //        }
        
        worker.doImageDataRequest(image: request.image, completion: { (updatedImage, statusData) in
            //            if let data = updatedImage?.data {
            //               //print(data.getMetaData())
            //            }
            self.currentImage = updatedImage
            if self.currentImage != nil {
                let response = HalfRealTimeScene.SavePhoto.Response()
                //self.presenter?.presentSavePhoto(response: response)
            }
        })
    }
    
    func takeNextPhoto(request: HalfRealTimeScene.TakeNextPhoto.Request) {
        self.doNextPhoto(request: request)
    }
    
    func start(request: HalfRealTimeScene.Start.Request) {
        YaMotionManager.sharedInstance.delegate = self
        YaMotionManager.sharedInstance.updateState()
        YaLocationManager.sharedInstance.delegate = self
        YaLocationManager.sharedInstance.startUpdating()
        self.errorsInARow = 0
        self.stickers = nil
        self.isCameraStopped = self.currentOpenViewsNum > 0
        self.localizeIsFirstAttempt = true
        self.stopKFS = true
        
        let response = HalfRealTimeScene.Start.Response(isStartFetching: request.isStartFetching && !(self.isCameraStopped))
        presenter?.presentStart(response: response)
    }
    
    func justSavePhoto(request: HalfRealTimeScene.JustSavePhoto.Request) {
        if !isCameraStopped {
            self.currentImage = request.image
        }
    }
    
    func show2DMarkers(request: HalfRealTimeScene.Nodes.Request) {
        self.currentDeviceOrientation = request.deviceOrientation
        self.calcStickerNodes(maybeNodes: request.maybeNodes, maybeStickers: request.maybeStickers)
    }
    
    private func getVideSticker(by sid: Int, context: ArCameraContext) -> ARFVideoNode? {
        guard let arkitView = context.arkitView else {
            return nil
        }
        
        for child in arkitView.scene.rootNode.childNodes {
            if let node = child as? ARFVideoNode, node.name?.hashValue == sid {
                return node
            }
        }

        return nil
    }
    
    private func isVideoSticker(stickerData: StickerModels.StickerData) -> Bool {
        if let urlString = stickerData.options[StickerOptions.path], urlString.suffix(4) == ".mp4", let _ = URL(string: urlString)  {
            return true
        }
        return false
    }
    
    func move2DMarkers(request: HalfRealTimeScene.Markers2DMovable.Request) {
        
        guard !self.isCameraStopped, self.currentImage?.size != nil else {
            return
        }
        
        // move to main thread
        guard Thread.isMainThread else {
            moveMarkerCounter += 1
            let counter = moveMarkerCounter
            
            DispatchQueue.main.async { [weak self] in
                guard counter == self?.moveMarkerCounter ?? 0 else {
                    print("[test] test thread in move2DMarkers")
                    return
                }
                
                self?.move2DMarkers(request: request)
            }
            return
        }
    
        self.currentDeviceOrientation = request.deviceOrientation
       
        //MARK: move nodes
       
        let (dictP, nums): ([Int:CGPoint]?, [Int:Int]?) = self.worker?.calcAR2DCentralPoints(maybeNodes: request.maybeNodes, windowSize: self.pinView?.frame.size ?? self.windowSize, maybeDeviceOrientation: self.currentDeviceOrientation) ?? (nil,nil)
       
        var stickerItems: [StickerViewDistance] = []
        
        for (id, markerView) in self.stickerSceneViews {
            let videoNode = getVideSticker(by: id, context: request.context)
            if let centralPoint = dictP?[id],
                let isInBounds = self.worker?.nodeInBounds(p: centralPoint, windowSize: self.pinView?.frame.size ?? self.windowSize),
                isInBounds, (markerView.currentType.isSame(type: self.currentCategoryPin) || videoNode != nil),
                let stickerNodes = request.maybeNodes,
                let distance = stickerNodes.first(where: {$0.id == id})?.distance {
        
                markerView.move(centralPoint: centralPoint)
                stickerItems.append((markerView, distance))
            } else {
                markerView.isHidden = true
                videoNode?.pause()
            }
        }
        
        // sort items on pins and stickers
        
        stickerItems.sort {$0.distance < $1.distance}
        let maxIndex = stickerSceneViews.count
        
        func getPose(id: Int) -> simd_float4x4? {
            if let arkitView = request.context.arkitView, let items = request.context.currentScene?.getStickerNodes(by: id) {
                return self.contentStickerPose(items: items, arkitView: arkitView)?.pose
            }
            return nil
        }
        
        for (index, item) in stickerItems.enumerated() {
            let distance = arStickerDistanceEnabled ? item.distance: nil
            let videoNode = getVideSticker(by: item.sticker.stickerData?.id ?? 0, context: request.context)
            let isVideo = item.sticker.stickerData != nil ? isVideoSticker(stickerData: item.sticker.stickerData!) : false
            
            if videoNode != nil, let id = item.sticker.stickerData?.id, let pose = getPose(id: id) {
                videoNode?.simdWorldTransform = pose
            }
            
            if index < stickersLimit {
                item.sticker.setViewType(isVideo ? .video : .sticker, distance: distance)
                item.sticker.isHidden = isVideo
                item.sticker.layer.zPosition = CGFloat(maxIndex - index)
                item.sticker.alpha = 1.0
                
                if !(videoNode?.stopped ?? false) {
                    videoNode?.play()
                }
            } else if item.distance < Double(arPinMaxDistance) {
                item.sticker.setViewType(isVideo ? .video : .pin, distance: distance)
                item.sticker.isHidden = isVideo
                item.sticker.layer.zPosition = CGFloat(maxIndex - index)
                item.sticker.alpha = CGFloat(arPinMaxDistance > 0 ? max(0, 1 - item.distance/Double(arPinMaxDistance)): 1.0)
                
                if !(videoNode?.stopped ?? false) {
                    videoNode?.play()
                }
            } else {
                item.sticker.isHidden = true
                videoNode?.pause()
            }
        }
        
        //MARK: do clusters here
        //self.makeClusters(stickers: stickerItems.filter { $0.0.viewType == .sticker }.map{ $0.0 })
        
        DispatchQueue.main.async {
            let _ =  self.worker?.alignStickers(views: stickerItems.filter { $0.0.viewType == .sticker }.map{ $0.0 }, pinViewSize: self.pinView?.frame.size ?? self.windowSize)
        }
        
        if !self.stickersShown {
            self.showStickerNodes()
        }
        
        if let stickerMarkerFrameViews = self.stickerMarkerFrameViews, let nodes = request.maybeNodes {
            for node in nodes {
                if let markerFrameView = stickerMarkerFrameViews[node.id!], let points = node.points {
                    if let isInBounds = self.worker?.nodesInBounds(arrP: points, windowSize: self.pinView?.frame.size ?? self.windowSize), isInBounds {
                        markerFrameView.move(stickerFramePoints: points)
                        markerFrameView.isHidden = false
                    } else {
                       markerFrameView.isHidden = true
                    }
                }
            }
        }
        
        // check info stickers
        var nearObjectsPins: ScreenNearObjectsPins = (.none, .none)
        if stickerItems.isEmpty, !stickerSceneViews.isEmpty {
            nearObjectsPins = request.context.findNearestObjects(cameraPose: request.cameraPose, prev: prevNearObjectsPins)
        }
        
        prevNearObjectsPins = nearObjectsPins
        let response = HalfRealTimeScene.Markers2DMovable.Response(nearObjectsPins: nearObjectsPins)
        presenter?.presentMarkers2DMovable(response: response)
        
        // update content stickers
        self.updateContentStickers(context: request.context)
    }
    
    //window size
    func makeSettings(request: HalfRealTimeScene.Settings.Request) {
        
        self.windowSize = request.pinViewSize
        
        //Init clusters
        let cols = Int(UIScreen.main.bounds.width) / clusterCellSize
        let rows = Int(UIScreen.main.bounds.height) / clusterCellSize
        self.defaultClusterizator = Array.init(repeating: [], count: cols * rows)
        
        self.stickerSceneViews.removeAll()
        self.stickerMarkerFrameViews?.removeAll()

        self.stickerMarkerFrameViewCompletion = { stickerMarkerFrameIndex in
            print("stickerMarkerFrameIndex = \(stickerMarkerFrameIndex)")
        }
        
        self.stickerClusterViewCompletion = { clusterSubArrayViewsID, data in
            //self.clusterizator[clusterSubArrayViewsID] == "[ID:Int] StickerView"
            print(clusterSubArrayViewsID)
        }
    }
    
    func updateArTrace(request: HalfRealTimeScene.ArTrace.Request) {
        if let arkitView = request.arkitView {
            self.arTraceManager.set(arkitView: arkitView)
        }
        if let cameraPose = request.cameraPose, let cameraAngles = request.cameraAngles {
            self.arTraceManager.updateTraces(cameraPose: cameraPose, cameraAngles: cameraAngles, maxDistance: 0.7)
        }
    }
    
    func setupArCreature(request: HalfRealTimeScene.ArCreature.Request) {
        if let arkitView = request.arkitView, let superView = request.superView {
            self.arCreatureManager.set(arkitView: arkitView)
            self.arCreatureManager.set(superView: superView)

            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.arCreatureManager.setupGestures()
            }
        }
    }

    // MARK: Anchors
    
    func handleAnchors(request: HalfRealTimeScene.HandleAnchors.Request) {
        let context = request.context
        let cameraManager = request.cameraManager
        guard let arkitView = cameraManager.arKitSceneView else {
            return
        }
        
        if let mainNode = context.getMainNode() {
                                   
            if context.anchorMode != .allStickers {
                for item in request.scene.arfNodes[mainNode.id]! {
                    if let node = item as? ARFSphereNode {
                        node.color = .blue
                    }
                }
            }
           
            switch context.anchorMode {
            case .points:
                for anchor in arkitView.session.currentFrame?.anchors ?? [] where anchor is ArPointAnchor {
                    arkitView.session.remove(anchor: anchor)
                }
                
                for item in request.scene.arfNodes[mainNode.id]! {
                    let anchor = ArPointAnchor(name: item.name!, transform: item.simdWorldTransform)
                    arkitView.session.add(anchor: anchor)
                }
                
                self.lastMainNodePoses = context.rebaseSceneToMainNode(mainNode)
                print("[anchor] rebase to main node mainNode:\(mainNode.id)")
                
            case .sticker:
                let nodes = request.scene.arfNodes[mainNode.id]!
                
                if let pose = context.createStickerAnchorPose(nodes: nodes) {
                    let anchor = ArStickerAnchor(name: mainNode.id, transform: pose)
                    arkitView.session.add(anchor: anchor)
                }
               
            default:
                break
            }
        } else if lastMainNodePoses != nil {
            print("[anchor] !!! node:\(lastMainNodePoses!.nodeId)")
            if let scene = context.currentScene, scene.parent != arkitView.scene.rootNode {
                lastMainNodePoses = nil
                let transform = scene.worldTransform
                arkitView.scene.rootNode.addChildNode(scene)
                scene.setWorldTransform(transform)
                print("[anchor] !!! rebase to root")
            }
        }
        
        switch context.anchorMode {
        case .image:
            if let result = context.createImageRef(orientation: .up) {
                cameraManager.setRefererenceImages([result.ref])
            } else {
                print("[anchor] image don't created")
                cameraManager.setRefererenceImages([])
            }
        case .allStickers:
            for (nideId, nodes) in request.scene.arfNodes {
                if let pose = context.createStickerAnchorPose(nodes: nodes) {
                    let anchor = ArStickerAnchor(name: nideId, transform: pose)
                    arkitView.session.add(anchor: anchor)
                }
            }
        default:
            break
        }
    }
    
    func rebaseToLastAnchor(request: HalfRealTimeScene.MainNode.Request) {
        let context = request.context
        if let mainNode = context.getMainNode(), mainNode.id == lastMainNodePoses?.nodeId {
            //updateQueue.async {
                _ = context.rebaseSceneToMainNode(mainNode, scenePose: request.prevScene.simdWorldTransform)
            print("[anchor] rebase to previous main node anchor, main node id:\(mainNode.id)")
            //}
        }
    }
    
    func createAnchor(request: HalfRealTimeScene.AnchorAction.Request) {
        let context = request.context
        let anchor = request.anchor
        let node = request.node
        
        guard let scene = context.currentScene else {
            return
        }
        
        if anchor is ARImageAnchor || anchor is ArStickerAnchor {
            //DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            updateQueue.async {
                if context.anchorMode == .allStickers {
                    context.rebaseStickerToAnchorNode(node, anchor: anchor, scene: scene)
                } else if context.anchorNode != node {
                    context.rebaseToAnchorNode(node)
                    print("[anchor] rebase all stickers to anchor node, anchor:\(anchor.name ?? "-")")
                }
            }
        }
    }
    
    private func updateContentStickers(context: ArCameraContext) {
        if let arkitView = context.arkitView, let scene = context.currentScene {
            for child in arkitView.scene.rootNode.childNodes {
                if child is ARFVideoNode, let sid = child.name, let items = scene.arfNodes[sid], items.count > 0 {
                    var center = simd_float3()
                    for item in items {
                        center += item.simdWorldPosition
                    }
                    child.simdWorldPosition = center / Float(items.count)
                    //print("[fix] update video position")
                }
            }
        }
    }
    
    func updateAnchor(request: HalfRealTimeScene.AnchorAction.Request) {
        let context = request.context
        let anchor = request.anchor
        
        guard let aid = anchor.name else {
            return
        }
        
        if let cameraAnchor = anchor as? ArCameraPoseAnchor, context.updatePose(id: aid, pose: cameraAnchor.transform) {
            
        } else if let pointAnchor = anchor as? ArPointAnchor, let nodePoses = lastMainNodePoses {
            // fix scene node
            self.lastMainNodePoses = context.fixScene(anchor: pointAnchor, nodePoses: nodePoses)
            updateContentStickers(context: context)
        }
    }
    
    // MARK: Video Sticker
    private func removeArContent(arkitView: ARSCNView) {
        lastVideoNodes = [:]
        for child in arkitView.scene.rootNode.childNodes {
            if let node = child as? ARFVideoNode, let name = node.name {
                node.cleanup()
                node.removeFromParentNode()
            }
        }
    }
    
    func removeArContent(request: HalfRealTimeScene.ClearArContent.Request) {
        if let arkitView = request.cameraManager.arKitSceneView {
            removeArContent(arkitView: arkitView)
        }
    }
    
    func clearArContent(request: HalfRealTimeScene.ClearArContent.Request) {
        let cameraManager = request.cameraManager
        if let childs = cameraManager.arKitSceneView?.scene.rootNode.childNodes {
            for child in childs {
                if let node = child as? ARFVideoNode, let name = node.name {
                    //node.cleanup()
                    //node.removeFromParentNode()
                    lastVideoNodes[name] = node
                }
            }
        }
        
        cameraManager.clearArNodes(clearAnchors: request.clearAnchors, clearContent: false)
    }
    
    private func contentStickerPose(items: [SCNNode], arkitView: ARSCNView) -> (pose: simd_float4x4, width: CGFloat)? {
        guard items.count > 0 else {
            return nil
        }
        
        var center = simd_float3()
        for item in items {
            center += item.simdWorldPosition
        }
        
        center = center / Float(items.count)
        
        let triples = Scene3D.sortRectNodes(arkitView: arkitView, items: items)!
        
        let p0 = triples[0].node.simdWorldPosition
        let p1 = triples[1].node.simdWorldPosition
        
        let v1 = triples[1].node.simdWorldPosition - triples[0].node.simdWorldPosition
        let v2 = triples[3].node.simdWorldPosition - triples[0].node.simdWorldPosition
        
        // sticker -normal
        var normal = SCNVector3.vecmul(a: SCNVector3(v1), b: SCNVector3(v2))
        normal = SCNVector3(x: normal.x, y: 0, z: normal.z)
        normal.normalize()
        
        var orientation = simd_quatf(from: simd_float3(0, 0, -1), to: simd_float3(normal.x, normal.y, normal.z))
        
        let ox = normalize(orientation.act(simd_float3(1, 0, 0)))
        let planeOrientation = simd_quatf(from: ox, to: normalize(p1 - p0))
        orientation = planeOrientation*orientation
        let width = CGFloat(length(p1 - p0))
        return (simd_float4x4(rotation: simd_float3x3(orientation), position: center), width)
    }
    
    func handleVideoSticker(request: HalfRealTimeScene.VideoSticker.Request) {
        let context = request.context
        let arkitView = request.arkitView
      
        guard let scene = context.currentScene else {
            return
        }
        
        var videoNode: ARFVideoNode?
        
        for (sid, items) in scene.arfNodes {
            
            guard let options = scene.getStickerOptions(by: sid), let urlString = options[StickerOptions.path], urlString.suffix(4) == ".mp4", let url = URL(string: urlString) else {
                continue
            }

            guard let result = self.contentStickerPose(items: items, arkitView: arkitView) else {
                continue
            }
            
            let pose = result.pose
            let width = result.width
            
            if let node = lastVideoNodes.removeValue(forKey: sid) {
                node.updateWidth(width)
                node.simdWorldTransform = pose
                print("[vs] use prev node")
                continue
            }
            
            videoNode = ARFVideoNode(width: width, height: -1, player: nil, thumb: UIImage(named: "launch")!)
            videoNode?.simdWorldTransform = pose
            videoNode?.name = sid
            
            if let node = videoNode {
        
                self.worker?.loadSource(url: url) { player in
                    guard player != nil else {
                        return
                    }
                    DispatchQueue.main.async { [weak self] in
                        if !(self?.isCameraStopped ?? true), self?.getVideSticker(by: sid.hashValue, context: context) == nil {
                            node.player = player
                            arkitView.scene.rootNode.addChildNode(node)
                            node.simdWorldTransform = pose
                            player?.play()
                            print("[test] add video id:\(sid)")
                        }
                    }
                }
                
            } else {
                break
            }
        }
        
        // remove old video nodes
        for (_, node) in lastVideoNodes {
            node.cleanup()
            
            if node.parent != nil {
                node.removeFromParentNode()
            }
        }
        
        lastVideoNodes = [:]
    }
    
    func kfsFrameSelector(request: HalfRealTimeScene.FrameSelector.Request) {
        let response = HalfRealTimeScene.FrameSelector.Response(posePixelBuffer: request.posePixelBuffer)
        presenter?.presentKfsFrameSelector(response: response)
    }
    
    func localize(request: HalfRealTimeScene.Localize.Request) {
        
        self.stopKFS = true

        self.currentImage = request.image
        
        var photoInfo: [String: Any] = [:]
        
        //MARK: photoInfo
        photoInfo["fx"] = request.intrinsics.columns.0.x
        photoInfo["fy"] = request.intrinsics.columns.1.y
        photoInfo["cx"] = request.intrinsics.columns.2.x
        photoInfo["cy"] = request.intrinsics.columns.2.y
//        photoInfo["rotation"] as Int //0, 90, 180, 270
//        photoInfo["focalLengthIn35mmFilm"] as Int
//        photoInfo["mirrored"] as Bool
        //localizeDataCompletion: ((_ imageData: Data?, _ location: CLLocation?, _ photoInfo: [String:String]?) -> Void)?
        self.localizeDataCompletion?(request.image.data, currentLocation ?? lastLocation, photoInfo, request.cameraPose)
        
        let response = HalfRealTimeScene.Localize.Response()
        self.presenter?.presentLocalize(response: response)

    }
    
    func getLocalizeData(request: HalfRealTimeScene.LocalizeData.Request) {
        self.localizeDataCompletion = request.completion
        self.stopKFS = false
        
        let response = HalfRealTimeScene.LocalizeData.Response()
        presenter?.presentLocalizeData(response: response)
    }
    
    func showARObjects(request: HalfRealTimeScene.ARObjects.Request) {
        let response = HalfRealTimeScene.ARObjects.Response(localizationResult: request.localizationResult)
        self.presenter?.presentARObjects(response: response)
    }
    
    func setDelegate(request: HalfRealTimeScene.Delegate.Request) {
        self.stickerDelegate = request.stickerDelegate

        let response = HalfRealTimeScene.Delegate.Response()
        self.presenter?.presentDelegate(response: response)
    }
    
    func delete(request: HalfRealTimeScene.Delete.Request) {
        self.stickers?[request.stickerID] = nil
        self.stickerSceneViews[request.stickerID] = nil
        self.stickerMarkerFrameViews?[request.stickerID] = nil
        
        showStickerNodes()
        
        let response = HalfRealTimeScene.Delete.Response()
        self.presenter?.presentDelete(response: response)
    }

}

extension HalfRealTimeSceneInteractor: YaMotionManagerDelegate {
    func motionManager(wrong state: String) {
        self.hasSensors = state.isEmpty
    }
}

extension HalfRealTimeSceneInteractor: YaLocationManagerDelegate {
    func update(location: CLLocation) {
        self.currentLocation = location
    }
}

