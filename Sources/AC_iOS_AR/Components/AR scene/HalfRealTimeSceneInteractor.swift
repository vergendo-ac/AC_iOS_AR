//
//  HalfRealTimeSceneInteractor.swift
//  YaPlace
//
//  Created by Rustam Shigapov on 11/09/2019.
//  Copyright (c) 2019 SKZ. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreLocation.CLLocation
import ARKit
import CoreMotion

typealias StickerViewDistance = (sticker: StickerSceneView, distance: Double)

public protocol StickerDelegate {
    func tapped(stickerID: Int, stickerData: StickerModels.StickerData?, framePoints: [CGPoint]?, imageData: Data?)
    func update(stickers: [StickerModels.StickerData])
    func wrongLocalization()
}

protocol HalfRealTimeSceneBusinessLogic {
    
    //func savePhoto(request: HalfRealTimeScene.SavePhoto.Request)
    
    func takeNextPhoto(request: HalfRealTimeScene.TakeNextPhoto.Request)
    
    func start(request: HalfRealTimeScene.Start.Request)
    func stop(request: HalfRealTimeScene.Stop.Request)

    func justSavePhoto(request: HalfRealTimeScene.JustSavePhoto.Request)
    
    func show2DMarkers(request: HalfRealTimeScene.Nodes.Request)
    func move2DMarkers(request: HalfRealTimeScene.Markers2DMovable.Request)
    
    func makeSettings(request: HalfRealTimeScene.Settings.Request)
    func doDeInit(request: HalfRealTimeScene.DeInit.Request)
    
    func restartArSession()
    
    func arCameraUpdateLocation(request: HalfRealTimeScene.UpdateLocation.Request)
    func arCameraUpdateDeviceMotion(request: HalfRealTimeScene.UpdateDeviceMotion.Request)
    func updateArTrackingState(request: HalfRealTimeScene.ArTrackingState.Request)
    
    func updateArTrace(request: HalfRealTimeScene.ArTrace.Request)
    func setupArCreature(request: HalfRealTimeScene.ArCreature.Request)
    func startArCameraManager(request: HalfRealTimeScene.StartArCamera.Request)
    
    func handleAnchors(request: HalfRealTimeScene.HandleAnchors.Request)
    func createAnchor(request: HalfRealTimeScene.AnchorAction.Request)
    func updateAnchor(request: HalfRealTimeScene.AnchorAction.Request)
    func rebaseToLastAnchor(request: HalfRealTimeScene.MainNode.Request)
    
    func handleVideoSticker(request: HalfRealTimeScene.VideoSticker.Request)
    func clearArContent(request: HalfRealTimeScene.ClearArContent.Request)
    func removeArContent(request: HalfRealTimeScene.ClearArContent.Request)
    
    func kfsFrameSelector(request: HalfRealTimeScene.FrameSelector.Request)
    func timerFrameSelector(request: HalfRealTimeScene.FrameSelector.Request, timerInterval: TimeInterval)
    func kfsClearParams()
    
    func localize(request: HalfRealTimeScene.Localize.Request)
    
    func getLocalizeData(request: HalfRealTimeScene.LocalizeData.Request)
    func showARObjects(request: HalfRealTimeScene.ARObjects.Request)
    
    func setDelegate(request: HalfRealTimeScene.Delegate.Request)
    func delete(request: HalfRealTimeScene.Delete.Request)
    
    func updateFilters(request: HalfRealTimeScene.StickerFilters.Request)
}

protocol HalfRealTimeSceneDataStore {
    var currentImage: ImageModels.Image? { get set }
    var stickers: [Int: StickerModels.StickerData]? { get set }
    var stickerClusterViewCompletion: (Int, StickerModels.StickerData?) -> () { get set }
    var stickerMarkerFrameViewCompletion: (Int) -> () { get set }
    var currentStickerData: StickerModels.StickerData? { get set }
    var currentOpenViewsNum: Int { get set }
    
    var stickerSubviewYPositionUpdate: (CGFloat?) -> () { get set }
    
    var hasSensors: Bool { get set}
    
    var stopKFS: Bool { get set }

}

class HalfRealTimeSceneInteractor: HalfRealTimeSceneDataStore {
    var presenter: HalfRealTimeScenePresentationLogic?
    var worker: HalfRealTimeSceneWorker?
    
    /// A serial queue for thread safety when modifying the SceneKit node graph.
    let updateQueue = DispatchQueue(label: Bundle.main.bundleIdentifier! +
        ".serialSceneKitQueue")
    let contentQueue = DispatchQueue(label: "\(Bundle.main.bundleIdentifier!).contentQueue", qos: .userInteractive)
    
    // HalfRealTimeSceneDataStore
    var currentImage: ImageModels.Image? {
        willSet {
            print("currentImage didSet == nil -> ", newValue == nil)
        }
    }
    var stickers: [Int: StickerModels.StickerData]?
    var stickerClusterViewCompletion: (Int, StickerModels.StickerData?) -> Swift.Void = {_,_  in }
    var stickerMarkerFrameViewCompletion: (Int) -> Swift.Void = {_ in }
    var currentStickerData: StickerModels.StickerData?
    var currentOpenViewsNum: Int = 0
    var stickerSubviewYPositionUpdate: (CGFloat?) -> Swift.Void = {_ in }
    weak var uiNavigationController: UINavigationController?
    var pinView: UIView?//PassthroughView?
    var hasSensors: Bool = false
    var stopKFS: Bool = true
    
    // arSession degradation parameters
    private var lastLocation: CLLocation?
    private var lastCameraPosition: simd_float3?
    private var lastMeasure: AccMeasure?
    private var countMeasures = 0
    private var degradationLimit: Float {
        return UserDefaults.restartArsLimitValue ?? 0
    }
    
    //REPLACE - MarkerSceneView
    var stickerSceneViews: [Int: StickerSceneView] = [:]
    var currentStickerId: Int = -1
    var currentLocation: CLLocation? = nil
    
    //local variables
    var testSticker2D: Bool = false // Bool sticker variable
    var windowSize: CGSize = .zero
    private var isCameraStopped: Bool = false
    var currentDeviceOrientation: UIDeviceOrientation? = .portrait
    var errorsInARowLimit = 10
    private var stickerMarkerFrameViews: [Int: StickerMarkerFrameSceneView]? = nil
    private var moveMarkerCounter = 0
    //MARK: Nodes num by sides
    private var leftPointsNum: Int?
    private var centralPointsNum: Int?
    private var rightPointsNum: Int?
    
    private var stickersShown: Bool = false
    private var stickerDelegate: StickerDelegate?
    
    private var arTraceManager = ArTraceManager.sharedInstance
    private var arCreatureManager = ArCreatureManager.sharedInstance
    private var arPinMaxDistance = UserDefaults.arPinMaxDistanceValue ?? 200
    private var arStickerDistanceEnabled = UserDefaults.arStickerDistanceEnabled ?? false
    private var stickersLimit = 5
    private var lastMainNodePoses: Node3dPoses?
    private var currentCategoryPin: InfoStickerCategory?
    private var prevNearObjectsPins: ScreenNearObjectsPins = (.none, .none)
    private var lastVideoNodes: [String: ARFVideoNode] = [:]
    private var getStickerFrame: (([StickerModels.Node]?) -> Void)? = nil
    
    //MARK: Clusters
    private let clusterCoordBinOffset: Int = 5 // 2ˆ5
    private let clusterCellSize: Int = 32 // 2ˆ5
    private var clusters: [Int: StickerSceneView] = [:]
    private var clusterizator: [[Int]] = []
    private var defaultClusterizator: [[Int]] = []
    
    //MARK: Localize
    private var localizeAttempts: Int = 0
    private let localizeAttemptsLimit: Int = 30
    private var localizeIsFirstAttempt: Bool = true
    private var localizeTimer: Timer?
    private var localizeDataCompletion: ((_ imageData: Data?, _ location: CLLocation?, _ photoInfo: [String:Any]?, _ cameraPose: Pose) -> Void)?
    
    //MARK: Relocalization
    private var relocalizeTimer: Timer?
    
    //MARK: Filters
    private var stickerFilters: [String:Bool] = [:]
    
    //MARK: Camera
    private var cameraManager: BaseCameraManagerProtocol = ArCameraManager.sharedInstance
    private var arBackView: UIView?
    private var cameraState: HalfRealCameraState = .normal(prev: nil) {
        didSet {
            let proc = {
                if let camera = (self.cameraManager as? ArCameraManager)?.arKitSceneView?.session.currentFrame?.camera {
                    self.arCameraManager(didUpdateSessionState: camera.trackingState)
                }
                
                switch self.cameraState {
                case .arkit:
                    print("arkit")
                default:
                    
                    print("default")
                }
            }
            Thread.isMainThread ? proc() : DispatchQueue.main.async(execute: proc)
        }
    }
    // MARK: Arkit properties
    private let syncRoot: NSRecursiveLock = NSRecursiveLock()
    private let anchorMode: ArCameraContext.AnchorMode = .off
    private let isArkitAutoScaleMode = false
    private var kfsSelectorEnabled = true
    private var arSessionStatusEnabled = false
    private static let requestDeadline = 1.0
    private var lastConfigOptions: ARSession.RunOptions?
    private var animationTimer: Timer?
    private var showArPlane = true
    private var arObjectsEnabled = true
    private var arAnimationDuration: TimeInterval = 1.5
    private let meshNodeName = "MeshNode"
    //ar presenter
    let nodeSize: CGSize = CGSize(width: 20, height: 20)
    private var errorsInRow = 0
    private var restartArSessionState: RestartArSessionState?
    private var animationTime: TimeInterval = 10
    private var goToStartScreenTime: TimeInterval = 30
    enum RestartArSessionState {
        case start(time: TimeInterval)
        case animation(time: TimeInterval)
        
        var time: TimeInterval {
            switch self {
            case .start(let time), .animation(let time):
                return time
            }
        }
        
        var isAnimation: Bool {
            switch self {
            case .animation:
                return true
            default:
                return false
            }
        }
    }
    

    var errorsInARow: Int = 0 {
        didSet {
            print("errorsInARow = \(errorsInARow)")
        }
    }
    
    private func doPhotoResponse(maybeResponse: NetModels.Response2D?) {
        if let response = maybeResponse {
            self.errorsInARow = 0
            if let nodes = response.nodes, let stickers = response.stickers {
                self.calcStickerNodes(maybeNodes: nodes, maybeStickers: stickers) {
                    self.showStickerNodes()
                }
            } else {
                self.doClear2DMarkers()
            }
        }
    }
    
    private func showStickerNodes() {
        self.stickersShown = true
        self.doPresentNodes()
    }
    
    private func calcStickerNodes(maybeNodes: [StickerModels.Node]?, maybeStickers: [StickerModels.StickerData]?, completion: (() -> Void)? = nil) {
        var maybeStickerNodes: [StickerModels.StickerNode]? = nil
        var maybeStickerFrames: [Int:PointModels.DistantFramePoints]? = nil
        
        self.stickersShown = false

//        self.stickerMarkerViews.removeAll()
//        self.stickerMarkerFrameViews?.removeAll()
        
        //MARK: Calc stickers & frames points
        if let imageSize = self.currentImage?.size, let nodes = maybeNodes, let stickers = maybeStickers, nodes.count == stickers.count,
            let triplePoints = self.worker?.calcNodesTriplePoints(maybeNodes: nodes, imageSize: imageSize, windowSize: self.pinView?.frame.size ?? self.windowSize, maybeDeviceOrientation: self.currentDeviceOrientation),
            let framePoints = triplePoints.framePoints {
            
            stickerDelegate?.update(stickers: stickers)
            
            //save all stickers as key-value pairs
            self.stickers = (stickers.reduce(into: (-1, [:]), { (acc, sticker) in
                acc.0 = sticker.id!
                acc.1[sticker.id!] = sticker
            })).1
            
            let calcNodesFrames: ([Int:PointModels.DistantPoint]?) -> Void = { [weak self] points in
                if let points = points {
                    maybeStickerNodes = self?.worker?.makeStickerNodes(points: points, maybeStickers: self?.stickers)
                    maybeStickerFrames = framePoints.filter({ (key, _) -> Bool in
                        points.keys.contains(key)
                    })
                }
            }
            
            if let arCameraEnabled = UserDefaults.arCameraEnabled {
                calcNodesFrames((arCameraEnabled) ? triplePoints.allPoints : triplePoints.centralPoints)
            } else {
                calcNodesFrames(triplePoints.centralPoints)
            }

            leftPointsNum = triplePoints.leftPoints?.count
            centralPointsNum = triplePoints.centralPoints?.count
            rightPointsNum = triplePoints.rightPoints?.count
            
        } else {
            print("HalfRealTimeSceneInteractor: doStickerNodes: \((maybeNodes?.count) ?? 0) =? \((maybeStickers?.count) ?? 0)")
        }
        
        //MARK: Build stickers
        if let stickerNodes = maybeStickerNodes {
            let isAR = (UserDefaults.arCameraEnabled ?? false)
            let isARFun = (UserDefaults.arFun ?? false)
            let isARObjectsEnabled = (UserDefaults.arObjectsEnabled ?? false)
            let weHave3DSticker = (UserDefaults.current3DSticker != nil && UserDefaults.current3DSticker! != Sticker3DHelper.Sticker3DSourceType.none.name)
            let hideStickerMarker: Bool = isAR && isARFun && isARObjectsEnabled && weHave3DSticker
            
            self.stickerSceneViews = stickerNodes.reduce(into: [:], { (acc, stickerNode) in
                acc[stickerNode.id] = StickerSceneView(
                  stickerId: stickerNode.id,
                  stickerDistancePoint: stickerNode.distantPoint,
                  stickerData: stickerNode.stickerData,
                  hideStickerMarker: hideStickerMarker,
                  pinView: pinView ?? PassthroughView(),
                  stickerMarkerViewCompletion: { [weak self] (id, data) in
                    self?.getStickerFrame = { mNodes in
                        self?.getStickerFrame = nil
                        var framePoints: [CGPoint] = []
                        if let nodes = mNodes, let points = nodes.first(where: { $0.id == stickerNode.id })?.points {
                            framePoints = points
                        }
                        
                        self?.cameraManager.takePhoto(completion: { (mData, mAlert, mDeviceOrientation) in
                            self?.stickerDelegate?.tapped(stickerID: id, stickerData: data, framePoints: framePoints, imageData: mData)
                        })
                        
                    }
                  }
                )
                acc[stickerNode.id]?.isHidden = true
            })
        }

        //MARK: Build frames
        
        if (UserDefaults.showStickerFrameMode ?? false), let stickerFrames = maybeStickerFrames {
            self.stickerMarkerFrameViews = stickerFrames.reduce(into: [:], { (acc, stickerFrame) in
                let (key, stickerFramePoints) = stickerFrame
                acc?[key] = StickerMarkerFrameSceneView.init(
                    index: key,
                    stickerDistantFramePoints: stickerFramePoints,
                    stickerMarkerFrameViewCompletion: self.stickerMarkerFrameViewCompletion
                )
            })
        } else {
            self.stickerMarkerFrameViews = nil
        }
        
        //self.stickerMarkerFrameViews = nil
        completion?()
        
    }
    
    //TODO: - updateStickersPosition
    private func doPresentNodes() {
        print(self.stickerSceneViews.count)
        //let chessedView = worker?.chessStickers(views: self.stickerMarkerViews.values.reduce(into: [], { $0.append($1) }))
        //let positionViews = worker?.updateStickersPosition(views: stickerMarkerViews.values.reduce(into: [], { $0.append($1) }), pinViewSize: pinView?.frame.size ?? windowSize)
        let positionViews = worker?.alignStickers(views: stickerSceneViews.values.reduce(into: [], { $0.append($1) }), pinViewSize: pinView?.frame.size ?? windowSize)
        let response = HalfRealTimeScene.Nodes.Response (
            views: Array(stickerSceneViews.values),
            frames: self.stickerMarkerFrameViews?.values.reduce(into: [], { $0.append($1) })
        )
        self.presenter?.presentNodes(response: response)
    }
    
    /*private func doNextPhoto(request: HalfRealTimeScene.TakeNextPhoto.Request) {
        if self.errorsInARow < self.errorsInARowLimit, !self.isCameraStopped {
            let response = HalfRealTimeScene.TakeNextPhoto.Response(completion: request.completion)
            presenter?.presentTakeNextPhoto(response: response)
        }
    }*/
    
    private func doClear2DMarkers() {
        self.stickers?.removeAll()
        self.stickerSceneViews.removeAll()
        self.stickerMarkerFrameViews?.removeAll()
        
        self.doPresentNodes()
    }
    
    private func parse2DTest() {
        worker?.parse2DTest(completion: { [weak self] (response, status) in
            guard let self = self else { return }
            if !self.isCameraStopped {
                self.doPhotoResponse(maybeResponse: response)
            }
        })
    }
    
    private func makeClusters(stickers: [StickerSceneView]) {
        //Clear clusters
        self.clusterizator = self.defaultClusterizator
        self.clusters = [:]
        
        //Collect clusters
        stickers.forEach {
            let newX = Int($0.stickerCentralPoint.x) >> self.clusterCoordBinOffset
            let newY = Int($0.stickerCentralPoint.y) >> self.clusterCoordBinOffset
            let index = newY * newX + newX
            self.clusterizator[index].append($0.stickerId)
        }
        
        //Make cluster central point
        //TODO: central distance
        let prepareCentralPoint: (Int, [Int]) -> (Int, CGPoint) = { index, arrStickerIndex in
            let centralPoints: [CGPoint] = arrStickerIndex.compactMap {
                self.stickerSceneViews[$0]?.isHidden = true
                return self.stickerSceneViews[$0]?.stickerCentralPoint
            }
            let centralPoint: (CGFloat, CGFloat) = centralPoints.reduce(into: (0, 0), { $0 = ($0.0 + $1.x, $0.1 + $1.y) })
            return (index, CGPoint(x: centralPoint.0 / CGFloat(centralPoints.count), y: centralPoint.1 / CGFloat(centralPoints.count)))
        }
        
        let clusterID = UUID().hashValue
        self.clusterizator.enumerated().filter { $1.count > 1 }.map { prepareCentralPoint($0, $1) }.forEach { (index, cP) in
            let clusterView = StickerSceneView(
                stickerId: index,
                stickerDistancePoint: PointModels.DistantPoint(1.0, cP), //TODO: distance!
                stickerData: nil,
                hideStickerMarker: true,
                pinView: self.pinView ?? PassthroughView(),
                stickerMarkerViewCompletion: { _,_ in } //self.stickerClusterViewCompletion
            )
            clusterView.set(tag: .StickerMarkerClusterView)
            clusterView.viewType = .cluster //show cluster picture
            self.clusters[clusterID] = clusterView
        }
        
        print(self.clusters.count)
        
        //Show clusters
        let response = HalfRealTimeScene.Clusters.Response(clusters: Array(self.clusters.values))
        presenter?.presentClusters(response: response)
    }
    
}

extension HalfRealTimeSceneInteractor: HalfRealTimeSceneBusinessLogic {
    
    func kfsClearParams() {
        self.stopKFS = false
    }
    
    func startArCameraManager(request: HalfRealTimeScene.StartArCamera.Request) {
        arPinMaxDistance = UserDefaults.arPinMaxDistanceValue ?? 200
        arStickerDistanceEnabled = UserDefaults.arStickerDistanceEnabled ?? false
    }
    
    func doDeInit(request: HalfRealTimeScene.DeInit.Request) {
        self.currentImage = nil
        self.stickers = nil
        self.stickerClusterViewCompletion = {_,_  in }
        self.currentStickerData = nil
        self.currentOpenViewsNum = 0
        self.uiNavigationController = nil
        self.stickerSceneViews = [:]

        let response = HalfRealTimeScene.DeInit.Response()
        //presenter?.presentDeInit(response: response) 
        
        self.presenter = nil
        self.worker = nil
    }
    
    func restartArSession() {
        self.localizeIsFirstAttempt = true
        self.localizeAttempts = 0
        
        let response = HalfRealTimeScene.ArSessionRun.Response(options: [.resetTracking])
        self.presentArSessionRun(response: response)
    }
    
    private func countAccDegradationFactor(position: simd_float3, location: CLLocation? = nil) -> (factor: HalfRealTimeScene.DegradationFactor, distanceType: HalfRealTimeScene.DistanceType)? {
        
        guard degradationLimit > 0 else {
            return nil
        }
        
        if let lastPosition = self.lastCameraPosition, let measure = self.lastMeasure {
            let arkitX = (lastPosition - position).norma()
            var distance = max(0.1, Float(measure.x.norma()))
            var distanceType: HalfRealTimeScene.DistanceType = .acc
            
            if let updateLocation = location, let lastLocatiom = self.lastLocation {
                let d = Float(lastLocatiom.distance(from: updateLocation))
                
                if d >= 1 && d > Float(updateLocation.horizontalAccuracy)/2 {
                    distance = d
                    distanceType = .gps
                }
            }
            
            if distance > 0 {
                let f = arkitX/distance
                
                if f > self.degradationLimit {
                    return (HalfRealTimeScene.DegradationFactor.degradated(factor: f), distanceType)
                } else {
                    return (HalfRealTimeScene.DegradationFactor.normal(factor: f), distanceType)
                }
            }
        }
        return nil
    }
    
    func arCameraUpdateLocation(request: HalfRealTimeScene.UpdateLocation.Request) {
        DispatchQueue.main.async() {
            
            if let result = self.countAccDegradationFactor(position: request.cameraPosition, location: request.location) {
                
                switch result.factor {
                    case .degradated:
                        self.kfsClearParams()
                        self.restartArSession()
                    default:
                        break
                }
                
                let response = HalfRealTimeScene.ArSessionStatus.Response(factor: result.factor, disatnceType: result.distanceType, trackingState: request.trackingState, state: request.state)
                self.presentArSessionStatus(response: response)
            }
            
            self.lastCameraPosition = request.cameraPosition
            self.lastLocation = request.location
            self.lastMeasure = nil
            self.countMeasures = 0
        }
    }
    
    func arCameraUpdateDeviceMotion(request: HalfRealTimeScene.UpdateDeviceMotion.Request) {
        
        let a = request.deviceMotion.userAcceleration
        let f = 0.993
        let G = 9.81

        guard let prev = lastMeasure else {
            lastMeasure = AccMeasure(simd_double3(a.x, a.y, 0))
            return
        }

        let curr = AccMeasure(simd_double3(a.x, a.y, 0))
        let dt = curr.t - prev.t

        curr.v = f*prev.v + G*(dt/2)*(curr.a + prev.a)
        curr.x = prev.x + dt*curr.v

        lastMeasure = curr
        countMeasures += 1

        if countMeasures > 0, countMeasures % 100 == 0,
            let result = countAccDegradationFactor(position: request.cameraPosition) {
            
            print("[lock] check factor:\(result.factor), count:\(countMeasures)")
            
            switch result.factor {
                case .degradated:
                    self.kfsClearParams()
                    self.restartArSession()
                    let response = HalfRealTimeScene.ArSessionStatus.Response(factor: result.factor, disatnceType: result.distanceType, trackingState: request.trackingState, state: request.state)
                    self.presentArSessionStatus(response: response)
                
                    self.lastLocation = nil
                    self.lastMeasure = nil
                    self.countMeasures = 0
                default:
                    break
            }
        }
    }
    
    func updateArTrackingState(request: HalfRealTimeScene.ArTrackingState.Request) {
        let response = HalfRealTimeScene.ArTrackingState.Response(trackingState: request.trackingState, state: request.state)
        self.presentArTrackingState(response: response)
    }
    
    /*func savePhoto(request: HalfRealTimeScene.SavePhoto.Request) {
        self.currentDeviceOrientation = request.deviceOrientation
        self.currentLocation = request.currentLocation ?? self.currentLocation
        guard let worker = self.worker else {
            print("HalfRealTimeSceneInteractor: No worker")
            return
        }
        //        if let data = request.image?.data {
        //            //print(data.getMetaData())
        //        }
        
        worker.doImageDataRequest(image: request.image, completion: { (updatedImage, statusData) in
            //            if let data = updatedImage?.data {
            //               //print(data.getMetaData())
            //            }
            self.currentImage = updatedImage
            if self.currentImage != nil {
                let response = HalfRealTimeScene.SavePhoto.Response()
                //self.presenter?.presentSavePhoto(response: response)
            }
        })
    }*/
    
    func takeNextPhoto(request: HalfRealTimeScene.TakeNextPhoto.Request) {
        self.cameraManager.takePhoto(completion: request.completion)
    }
    
    func start(request: HalfRealTimeScene.Start.Request) {
        YaMotionManager.sharedInstance.delegate = self
        YaMotionManager.sharedInstance.updateState()
        YaLocationManager.sharedInstance.delegate = self
        YaLocationManager.sharedInstance.startUpdating()
        self.errorsInARow = 0
        self.stickers = nil
        self.isCameraStopped = self.currentOpenViewsNum > 0
        self.localizeIsFirstAttempt = true
        self.stopKFS = true
        self.arBackView = request.arBackView
        self.stickerFilters = UserDefaults.objectFilter ?? [:]
        
        let isStartFetching = (self.arBackView != nil) && !(self.isCameraStopped)
        
        if isStartFetching {
            self.startAR()
        }
        
        
        let response = HalfRealTimeScene.Start.Response()
        presenter?.presentStart(response: response)
    }
    
    func stop(request: HalfRealTimeScene.Stop.Request) {
        DispatchQueue.main.async {
            UIApplication.shared.isIdleTimerDisabled = false
            self.switchCamera(isON: false)
        }
    }
    
    func justSavePhoto(request: HalfRealTimeScene.JustSavePhoto.Request) {
        if !isCameraStopped {
            self.currentImage = request.image
        }
    }
    
    func show2DMarkers(request: HalfRealTimeScene.Nodes.Request) {
        self.currentDeviceOrientation = request.deviceOrientation
        self.calcStickerNodes(maybeNodes: request.maybeNodes, maybeStickers: request.maybeStickers)
    }
    
    private func getVideSticker(by sid: Int, context: ArCameraContext) -> ARFVideoNode? {
        guard let arkitView = context.arkitView else {
            return nil
        }
        
        for child in arkitView.scene.rootNode.childNodes {
            if let node = child as? ARFVideoNode, node.name?.hashValue == sid {
                return node
            }
        }

        return nil
    }
    
    func move2DMarkers(request: HalfRealTimeScene.Markers2DMovable.Request) {
        
        guard !self.isCameraStopped, self.currentImage?.size != nil else {
            return
        }
        
        // move to main thread
        guard Thread.isMainThread else {
            moveMarkerCounter += 1
            let counter = moveMarkerCounter
            
            DispatchQueue.main.async { [weak self] in
                guard counter == self?.moveMarkerCounter ?? 0 else {
                    print("[test] test thread in move2DMarkers")
                    return
                }
                
                self?.move2DMarkers(request: request)
            }
            return
        }
    
        self.currentDeviceOrientation = request.deviceOrientation
        
        //MARK: move nodes
        
        getStickerFrame?(request.maybeNodes)
       
        let (dictP, nums): ([Int:CGPoint]?, [Int:Int]?) = self.worker?.calcAR2DCentralPoints(maybeNodes: request.maybeNodes, windowSize: self.pinView?.frame.size ?? self.windowSize, maybeDeviceOrientation: self.currentDeviceOrientation) ?? (nil,nil)
       
        var stickerItems: [StickerViewDistance] = []

        //filter nodes by type or category
        let isFilteredOut: (_ sceneView: StickerSceneView) -> Bool = { sceneView in
            let viewTypeFilter: Bool = self.stickerFilters[sceneView.viewType.title] ?? false
            let currentTypeFilter: Bool = self.stickerFilters[sceneView.currentType.title] ?? false
            
            if sceneView.viewType.isVideo, let videoNode = self.getVideSticker(by: sceneView.stickerData?.id ?? 0, context: request.context) {
                videoNode.isHidden = !viewTypeFilter
                if viewTypeFilter {
                    videoNode.play()
                } else {
                    videoNode.stop()
                }
            }
            
            print("StickerFilters TypeCheck", sceneView.viewType.title, viewTypeFilter, sceneView.currentType.title, currentTypeFilter)

            return viewTypeFilter || currentTypeFilter
        }
        
        print("StickerFilters New step")
        
        for (id, markerView) in self.stickerSceneViews {
            let videoNode = getVideSticker(by: id, context: request.context)
            if  isFilteredOut(markerView),
                let centralPoint = dictP?[id],
                let isInBounds = self.worker?.nodeInBounds(p: centralPoint, windowSize: self.pinView?.frame.size ?? self.windowSize),
                isInBounds, (markerView.currentType.isSame(type: self.currentCategoryPin) || videoNode != nil),
                let stickerNodes = request.maybeNodes,
                let distance = stickerNodes.first(where: {$0.id == id})?.distance {
                markerView.move(centralPoint: centralPoint)
                stickerItems.append((markerView, distance))
            } else {
                markerView.isHidden = true
                videoNode?.pause()
            }
        }
        
        
        
        // sort items on pins and stickers
        
        stickerItems.sort {$0.distance < $1.distance}
        let maxIndex = stickerSceneViews.count
        
        func getPose(id: Int) -> simd_float4x4? {
            if let arkitView = request.context.arkitView, let items = request.context.currentScene?.getStickerNodes(by: id) {
                return self.contentStickerPose(items: items, arkitView: arkitView)?.pose
            }
            return nil
        }
        
        for (index, item) in stickerItems.enumerated() {
            let distance = arStickerDistanceEnabled ? item.distance: nil
            let videoNode = getVideSticker(by: item.sticker.stickerData?.id ?? 0, context: request.context)
            let isVideo = item.sticker.viewType.isVideo
            
            if videoNode != nil, let id = item.sticker.stickerData?.id, let pose = getPose(id: id) {
                videoNode?.simdWorldTransform = pose
            }
            
            if index < stickersLimit {
                item.sticker.setViewType(isVideo ? .video : .sticker, distance: distance)
                item.sticker.isHidden = isVideo
                item.sticker.layer.zPosition = CGFloat(maxIndex - index)
                item.sticker.alpha = 1.0
                
                if !(videoNode?.stopped ?? false) {
                    videoNode?.play()
                }
            } else if item.distance < Double(arPinMaxDistance) {
                item.sticker.setViewType(isVideo ? .video : .pin, distance: distance)
                item.sticker.isHidden = isVideo
                item.sticker.layer.zPosition = CGFloat(maxIndex - index)
                item.sticker.alpha = CGFloat(arPinMaxDistance > 0 ? max(0, 1 - item.distance/Double(arPinMaxDistance)): 1.0)
                
                if !(videoNode?.stopped ?? false) {
                    videoNode?.play()
                }
            } else {
                item.sticker.isHidden = true
                videoNode?.pause()
            }
        }
        
        //MARK: do clusters here
        //self.makeClusters(stickers: stickerItems.filter { $0.0.viewType == .sticker }.map{ $0.0 })
        
        DispatchQueue.main.async {
            let _ =  self.worker?.alignStickers(views: stickerItems.filter { $0.0.viewType == .sticker }.map{ $0.0 }, pinViewSize: self.pinView?.frame.size ?? self.windowSize)
        }
        
        if !self.stickersShown {
            self.showStickerNodes()
        }
        
        if let stickerMarkerFrameViews = self.stickerMarkerFrameViews, let nodes = request.maybeNodes {
            for node in nodes {
                if let markerFrameView = stickerMarkerFrameViews[node.id!], let points = node.points {
                    if let isInBounds = self.worker?.nodesInBounds(arrP: points, windowSize: self.pinView?.frame.size ?? self.windowSize), isInBounds {
                        markerFrameView.move(stickerFramePoints: points)
                        markerFrameView.isHidden = false
                    } else {
                       markerFrameView.isHidden = true
                    }
                }
            }
        }
        
        // check info stickers
        var nearObjectsPins: ScreenNearObjectsPins = (.none, .none)
        if stickerItems.isEmpty, !stickerSceneViews.isEmpty {
            nearObjectsPins = request.context.findNearestObjects(cameraPose: request.cameraPose, prev: prevNearObjectsPins)
        }
        
        prevNearObjectsPins = nearObjectsPins
        let response = HalfRealTimeScene.Markers2DMovable.Response(nearObjectsPins: nearObjectsPins)
        self.presentMarkers2DMovable(response: response)
        
        // update content stickers
        self.updateContentStickers(context: request.context)
    }
    
    //window size
    func makeSettings(request: HalfRealTimeScene.Settings.Request) {
        
        self.windowSize = request.pinViewSize
        
        //Init clusters
        let cols = Int(UIScreen.main.bounds.width) / clusterCellSize
        let rows = Int(UIScreen.main.bounds.height) / clusterCellSize
        self.defaultClusterizator = Array.init(repeating: [], count: cols * rows)
        
        self.stickerSceneViews.removeAll()
        self.stickerMarkerFrameViews?.removeAll()

        self.stickerMarkerFrameViewCompletion = { stickerMarkerFrameIndex in
            print("stickerMarkerFrameIndex = \(stickerMarkerFrameIndex)")
        }
        
        self.stickerClusterViewCompletion = { clusterSubArrayViewsID, data in
            //self.clusterizator[clusterSubArrayViewsID] == "[ID:Int] StickerView"
            print(clusterSubArrayViewsID)
        }
    }
    
    func updateArTrace(request: HalfRealTimeScene.ArTrace.Request) {
        if let arkitView = request.arkitView {
            self.arTraceManager.set(arkitView: arkitView)
        }
        if let cameraPose = request.cameraPose, let cameraAngles = request.cameraAngles {
            self.arTraceManager.updateTraces(cameraPose: cameraPose, cameraAngles: cameraAngles, maxDistance: 0.7)
        }
    }
    
    func setupArCreature(request: HalfRealTimeScene.ArCreature.Request) {
        if let arkitView = request.arkitView, let superView = request.superView {
            self.arCreatureManager.set(arkitView: arkitView)
            self.arCreatureManager.set(superView: superView)

            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.arCreatureManager.setupGestures()
            }
        }
    }

    // MARK: Anchors
    
    func handleAnchors(request: HalfRealTimeScene.HandleAnchors.Request) {
        let context = request.context
        let cameraManager = request.cameraManager
        guard let arkitView = cameraManager.arKitSceneView else {
            return
        }
        
        if let mainNode = context.getMainNode() {
                                   
            if context.anchorMode != .allStickers {
                for item in request.scene.arfNodes[mainNode.id]! {
                    if let node = item as? ARFSphereNode {
                        node.color = .blue
                    }
                }
            }
           
            switch context.anchorMode {
            case .points:
                for anchor in arkitView.session.currentFrame?.anchors ?? [] where anchor is ArPointAnchor {
                    arkitView.session.remove(anchor: anchor)
                }
                
                for item in request.scene.arfNodes[mainNode.id]! {
                    let anchor = ArPointAnchor(name: item.name!, transform: item.simdWorldTransform)
                    arkitView.session.add(anchor: anchor)
                }
                
                self.lastMainNodePoses = context.rebaseSceneToMainNode(mainNode)
                print("[anchor] rebase to main node mainNode:\(mainNode.id)")
                
            case .sticker:
                let nodes = request.scene.arfNodes[mainNode.id]!
                
                if let pose = context.createStickerAnchorPose(nodes: nodes) {
                    let anchor = ArStickerAnchor(name: mainNode.id, transform: pose)
                    arkitView.session.add(anchor: anchor)
                }
               
            default:
                break
            }
        } else if lastMainNodePoses != nil {
            print("[anchor] !!! node:\(lastMainNodePoses!.nodeId)")
            if let scene = context.currentScene, scene.parent != arkitView.scene.rootNode {
                lastMainNodePoses = nil
                let transform = scene.worldTransform
                arkitView.scene.rootNode.addChildNode(scene)
                scene.setWorldTransform(transform)
                print("[anchor] !!! rebase to root")
            }
        }
        
        switch context.anchorMode {
        case .image:
            if let result = context.createImageRef(orientation: .up) {
                cameraManager.setRefererenceImages([result.ref])
            } else {
                print("[anchor] image don't created")
                cameraManager.setRefererenceImages([])
            }
        case .allStickers:
            for (nideId, nodes) in request.scene.arfNodes {
                if let pose = context.createStickerAnchorPose(nodes: nodes) {
                    let anchor = ArStickerAnchor(name: nideId, transform: pose)
                    arkitView.session.add(anchor: anchor)
                }
            }
        default:
            break
        }
    }
    
    func rebaseToLastAnchor(request: HalfRealTimeScene.MainNode.Request) {
        let context = request.context
        if let mainNode = context.getMainNode(), mainNode.id == lastMainNodePoses?.nodeId {
            //updateQueue.async {
                _ = context.rebaseSceneToMainNode(mainNode, scenePose: request.prevScene.simdWorldTransform)
            print("[anchor] rebase to previous main node anchor, main node id:\(mainNode.id)")
            //}
        }
    }
    
    func createAnchor(request: HalfRealTimeScene.AnchorAction.Request) {
        let context = request.context
        let anchor = request.anchor
        let node = request.node
        
        guard let scene = context.currentScene else {
            return
        }
        
        if anchor is ARImageAnchor || anchor is ArStickerAnchor {
            //DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            updateQueue.async {
                if context.anchorMode == .allStickers {
                    context.rebaseStickerToAnchorNode(node, anchor: anchor, scene: scene)
                } else if context.anchorNode != node {
                    context.rebaseToAnchorNode(node)
                    print("[anchor] rebase all stickers to anchor node, anchor:\(anchor.name ?? "-")")
                }
            }
        }
    }
    
    private func updateContentStickers(context: ArCameraContext) {
        if let arkitView = context.arkitView, let scene = context.currentScene {
            for child in arkitView.scene.rootNode.childNodes {
                if child is ARFVideoNode, let sid = child.name, let items = scene.arfNodes[sid], items.count > 0 {
                    var center = simd_float3()
                    for item in items {
                        center += item.simdWorldPosition
                    }
                    child.simdWorldPosition = center / Float(items.count)
                    //print("[fix] update video position")
                }
            }
        }
    }
    
    func updateAnchor(request: HalfRealTimeScene.AnchorAction.Request) {
        let context = request.context
        let anchor = request.anchor
        
        guard let aid = anchor.name else {
            return
        }
        
        if let cameraAnchor = anchor as? ArCameraPoseAnchor, context.updatePose(id: aid, pose: cameraAnchor.transform) {
            
        } else if let pointAnchor = anchor as? ArPointAnchor, let nodePoses = lastMainNodePoses {
            // fix scene node
            self.lastMainNodePoses = context.fixScene(anchor: pointAnchor, nodePoses: nodePoses)
            updateContentStickers(context: context)
        }
    }
    
    // MARK: Video Sticker
    private func removeArContent(arkitView: ARSCNView) {
        lastVideoNodes = [:]
        for child in arkitView.scene.rootNode.childNodes {
            if let node = child as? ARFVideoNode, let name = node.name {
                node.cleanup()
                node.removeFromParentNode()
            }
        }
    }
    
    func removeArContent(request: HalfRealTimeScene.ClearArContent.Request) {
        if let arkitView = request.cameraManager.arKitSceneView {
            removeArContent(arkitView: arkitView)
        }
    }
    
    func clearArContent(request: HalfRealTimeScene.ClearArContent.Request) {
        let cameraManager = request.cameraManager
        if let childs = cameraManager.arKitSceneView?.scene.rootNode.childNodes {
            for child in childs {
                if let node = child as? ARFVideoNode, let name = node.name {
                    //node.cleanup()
                    //node.removeFromParentNode()
                    lastVideoNodes[name] = node
                }
            }
        }
        
        cameraManager.clearArNodes(clearAnchors: request.clearAnchors, clearContent: false)
    }
    
    private func contentStickerPose(items: [SCNNode], arkitView: ARSCNView) -> (pose: simd_float4x4, width: CGFloat)? {
        guard items.count > 0 else {
            return nil
        }
        
        var center = simd_float3()
        for item in items {
            center += item.simdWorldPosition
        }
        
        center = center / Float(items.count)
        
        let triples = Scene3D.sortRectNodes(arkitView: arkitView, items: items)!
        
        let p0 = triples[0].node.simdWorldPosition
        let p1 = triples[1].node.simdWorldPosition
        
        let v1 = triples[1].node.simdWorldPosition - triples[0].node.simdWorldPosition
        let v2 = triples[3].node.simdWorldPosition - triples[0].node.simdWorldPosition
        
        // sticker -normal
        var normal = SCNVector3.vecmul(a: SCNVector3(v1), b: SCNVector3(v2))
        normal = SCNVector3(x: normal.x, y: 0, z: normal.z)
        normal.normalize()
        
        var orientation = simd_quatf(from: simd_float3(0, 0, -1), to: simd_float3(normal.x, normal.y, normal.z))
        
        let ox = normalize(orientation.act(simd_float3(1, 0, 0)))
        let planeOrientation = simd_quatf(from: ox, to: normalize(p1 - p0))
        orientation = planeOrientation*orientation
        let width = CGFloat(length(p1 - p0))
        return (simd_float4x4(rotation: simd_float3x3(orientation), position: center), width)
    }
    
    func handleVideoSticker(request: HalfRealTimeScene.VideoSticker.Request) {
        let context = request.context
        let arkitView = request.arkitView
      
        guard let scene = context.currentScene else {
            return
        }
        
        var videoNode: ARFVideoNode?
        
        for (sid, items) in scene.arfNodes {
            
            guard let options = scene.getStickerOptions(by: sid), let urlString = options[StickerOptions.path], urlString.suffix(4) == ".mp4", let url = URL(string: urlString) else {
                continue
            }

            guard let result = self.contentStickerPose(items: items, arkitView: arkitView) else {
                continue
            }
            
            let pose = result.pose
            let width = result.width
            
            if let node = lastVideoNodes.removeValue(forKey: sid) {
                node.updateWidth(width)
                node.simdWorldTransform = pose
                print("[vs] use prev node")
                continue
            }
            
            videoNode = ARFVideoNode(width: width, height: -1, player: nil, thumb: UIImage(named: "launch")!)
            videoNode?.simdWorldTransform = pose
            videoNode?.name = sid
            
            if let node = videoNode {
        
                self.worker?.loadSource(url: url) { player in
                    guard player != nil else {
                        return
                    }
                    DispatchQueue.main.async { [weak self] in
                        if !(self?.isCameraStopped ?? true), self?.getVideSticker(by: sid.hashValue, context: context) == nil {
                            node.player = player
                            arkitView.scene.rootNode.addChildNode(node)
                            node.simdWorldTransform = pose
                            player?.play()
                            print("[test] add video id:\(sid)")
                        }
                    }
                }
                
            } else {
                break
            }
        }
        
        // remove old video nodes
        for (_, node) in lastVideoNodes {
            node.cleanup()
            
            if node.parent != nil {
                node.removeFromParentNode()
            }
        }
        
        lastVideoNodes = [:]
    }
    
    //MARK: Relocalization
    func kfsFrameSelector(request: HalfRealTimeScene.FrameSelector.Request) {
        let response = HalfRealTimeScene.FrameSelector.Response(posePixelBuffer: request.posePixelBuffer)
        self.presentKfsFrameSelector(response: response)
    }
    
    func timerFrameSelector(request: HalfRealTimeScene.FrameSelector.Request, timerInterval: TimeInterval) {
        if relocalizeTimer == nil {
            relocalizeTimer = Timer.scheduledTimer(timeInterval: timerInterval, target: self, selector: #selector(updateRelocalizeTimer), userInfo: ["request": request], repeats: false)
            relocalizeTimer?.tolerance = 0.1
            RunLoop.current.add(relocalizeTimer!, forMode: .common)
            print("CVPixelBuffer: start timerr")
        }
    }
    @objc private func updateRelocalizeTimer(timer: Timer) {
        let userInfo = timer.userInfo as? Dictionary<String, Any>
        if let request = userInfo?["request"] as? HalfRealTimeScene.FrameSelector.Request {
            print("CVPixelBuffer: request.posePixelBuffer = ", CVPixelBufferGetWidth(request.posePixelBuffer.image))
            let response = HalfRealTimeScene.FrameSelector.Response(posePixelBuffer: request.posePixelBuffer)
            self.presentFrameSelector(response: response)
        } else {
            print("CVPixelBuffer no: request.posePixelBuffer")
        }
        relocalizeTimer?.invalidate()
        relocalizeTimer = nil
        kfsClearParams()
    }
    
    func localize(request: HalfRealTimeScene.Localize.Request) {
        
        self.stopKFS = true

        self.currentImage = request.image
        
        var photoInfo: [String: Any] = [:]
        
        //MARK: photoInfo
        photoInfo["fx"] = request.intrinsics.columns.0.x
        photoInfo["fy"] = request.intrinsics.columns.1.y
        photoInfo["cx"] = request.intrinsics.columns.2.x
        photoInfo["cy"] = request.intrinsics.columns.2.y
//        photoInfo["rotation"] as Int //0, 90, 180, 270
//        photoInfo["focalLengthIn35mmFilm"] as Int
//        photoInfo["mirrored"] as Bool
        //localizeDataCompletion: ((_ imageData: Data?, _ location: CLLocation?, _ photoInfo: [String:String]?) -> Void)?
        self.localizeDataCompletion?(request.image.data, currentLocation ?? lastLocation, photoInfo, request.cameraPose)
        
        if self.localizeDataCompletion == nil {
            stickerDelegate?.wrongLocalization()
        }
        
        let response = HalfRealTimeScene.Localize.Response()
        self.presenter?.presentLocalize(response: response)

    }
    
    func getLocalizeData(request: HalfRealTimeScene.LocalizeData.Request) {
        self.localizeDataCompletion = request.completion
        self.stopKFS = false
        
        let response = HalfRealTimeScene.LocalizeData.Response()
        self.presenter?.presentLocalizeData(response: response)
    }
    
    func showARObjects(request: HalfRealTimeScene.ARObjects.Request) {
        let response = HalfRealTimeScene.ARObjects.Response(localizationResult: request.localizationResult)
        self.presentARObjects(response: response)
    }
    
    func setDelegate(request: HalfRealTimeScene.Delegate.Request) {
        self.stickerDelegate = request.stickerDelegate

        let response = HalfRealTimeScene.Delegate.Response()
        self.presenter?.presentDelegate(response: response)
    }
    
    func delete(request: HalfRealTimeScene.Delete.Request) {
        self.stickers?[request.stickerID] = nil
        self.stickerSceneViews[request.stickerID] = nil
        self.stickerMarkerFrameViews?[request.stickerID] = nil
        
        showStickerNodes()
        
        let response = HalfRealTimeScene.Delete.Response()
        self.presenter?.presentDelete(response: response)
    }
    
    func updateFilters(request: HalfRealTimeScene.StickerFilters.Request) {
        if request.filters.count > 0 {
            self.stickerFilters = request.filters
        } else if let objectFilter = UserDefaults.objectFilter {
            self.stickerFilters = objectFilter
        }
        
        print("StickerFilters All: ", self.stickerFilters.map({ ($0, $1) }))
        self.presenter?.presentStickerFilters(response: HalfRealTimeScene.StickerFilters.Response())
    }

}

extension HalfRealTimeSceneInteractor: YaMotionManagerDelegate {
    func motionManager(wrong state: String) {
        self.hasSensors = state.isEmpty
    }
}

extension HalfRealTimeSceneInteractor: YaLocationManagerDelegate {
    func update(location: CLLocation) {
        self.currentLocation = location
    }
}

//MARK: AR camera actions
extension HalfRealTimeSceneInteractor {
    
    private func startAR() {
        self.switchCamera(isON: true)
    }
    
    private func restoreArCameraManager() {
        guard UserDefaults.arCameraEnabled ?? true, let cameraManager = (self.cameraManager as? ArCameraManager) else {
            return
        }
        
        arSessionStatusEnabled = (UserDefaults.arStatusEnabled ?? false)
        let context = ArCameraContext()
        context.setArPlaneMaxDistance(Double(UserDefaults.arPlaneMaxDistanceValue ?? 200))
        
        if context.arPlaneMaxDistance > 0 {
            context.setScaleCalculationType(.arkit)
            showArPlane = arSessionStatusEnabled
            if arSessionStatusEnabled, let arkitView = cameraManager.arKitSceneView {
                arkitView.debugOptions = [SCNDebugOptions.showFeaturePoints, SCNDebugOptions.showWorldOrigin]
            }
            
            let hitTestType: ARHitTestResult.ResultType
            switch UserDefaults.arHitTestTypeValue ?? 1 {
            case 0:
                hitTestType = .existingPlane
            case 1:
                hitTestType = .existingPlaneUsingExtent
            case 2:
                hitTestType = .existingPlaneUsingGeometry
            case 3:
                hitTestType = .featurePoint
            default:
                hitTestType = .existingPlaneUsingExtent
            }
            context.setArHitTestResult(hitTestType)
        } else {
            showArPlane = false
            context.setScaleCalculationType(.poses)
        }
        
        cameraManager.delegate = self
        
        if UserDefaults.arHeadingAlignEnabled ?? true {
            cameraManager.setWorldAlignment(.gravityAndHeading)
        } else {
            cameraManager.setWorldAlignment(.gravity)
        }
        
        kfsSelectorEnabled = UserDefaults.arKfsSelectorEnabled ?? false
        arObjectsEnabled = UserDefaults.arObjectsEnabled ?? false
        arAnimationDuration = UserDefaults.arAnimationDurationValue != nil ? TimeInterval(UserDefaults.arAnimationDurationValue!) : arAnimationDuration
        context.setAnimationDuration(arAnimationDuration)
        cameraManager.enableDebugInfo(false)
        let arCameraAnchorType = UserDefaults.arCameraAnchorType ?? 1
        
        switch arCameraAnchorType {
        case 1:
            context.setAnchorMode(.points)
        case 2:
            if arSessionStatusEnabled {
                cameraManager.enableDebugInfo(true)
            }
            context.setAnchorMode(.image)
        case 3:
            context.setAnchorMode(.sticker)
        case 4:
            context.setAnchorMode(.allStickers)
        default:
            context.setAnchorMode(.off)
        }
        
        cameraManager.resumeCaptureSession { _ in
            self.cameraState = .arkit(context: context, prev: nil)
            self.startArCameraManager(request: HalfRealTimeScene.StartArCamera.Request())
            self.sticker3DRequest()
            self.updateArTrace(arkitView: cameraManager.arKitSceneView, cameraPose: nil, cameraAngles: nil)
            self.setupArCreature(arkitView: cameraManager.arKitSceneView, superView: self.arBackView)
        }
        
    }
    
    private func restoreCameraManager() {
        guard let viewForAR = self.arBackView else { return }
        
        ArCameraManager.sharedInstance.addPreviewLayer(to: viewForAR)
        restoreArCameraManager()
    }
    
    func switchCamera(isON: Bool) {
        switch isON {
        case true:
            self.restoreCameraManager()
        default:
            if let cameraManager = cameraManager as? ArCameraManager {
                cameraManager.arKitSceneView?.session.pause()
                let request = HalfRealTimeScene.ClearArContent.Request(cameraManager: cameraManager, clearAnchors: true)
                self.removeArContent(request: request)
            }
            self.cameraManager.stopCaptureSession()
        }
    }
    
    private func updateArTrace(arkitView: ARSCNView?, cameraPose: simd_float4x4?, cameraAngles: simd_float3?) {
        let request = HalfRealTimeScene.ArTrace.Request(arkitView: arkitView, cameraPose: cameraPose, cameraAngles: cameraAngles)
        self.updateArTrace(request: request)
    }
    
    private func setupArCreature(arkitView: ARSCNView?, superView: UIView?) {
        let request = HalfRealTimeScene.ArCreature.Request(arkitView: arkitView, superView: superView)
        self.setupArCreature(request: request)
    }
    
    private func cleanUpUI() {
        if let cameraManager = cameraManager as? ArCameraManager {
            cameraManager.arKitSceneView?.session.pause()
            let request = HalfRealTimeScene.ClearArContent.Request(cameraManager: cameraManager, clearAnchors: true)
            self.removeArContent(request: request)
        }
    }
    
    private func timerSelectorRequest(posePixelBuffer: PixelBufferWithPose, timerInterval: TimeInterval) {
        guard self.cameraState.isArkit else {
            //print("[check] yet handling, isArkit:\(self.cameraState.isArkit)")
            return
        }
        
        print("[check] yet handling, isArkit:\(self.cameraState.isArkit)")
        
        DispatchQueue.main.async {
            let request = HalfRealTimeScene.FrameSelector.Request(posePixelBuffer: posePixelBuffer)
            self.timerFrameSelector(request: request, timerInterval: timerInterval)
        }
    }
    
    func restoreCameraState() {
        print("[loc] * lock restoreCameraState")
        syncRoot.lock()
        
        defer {
            syncRoot.unlock()
            print("[loc] * unlock restoreCameraState")
            self.sticker3DRequest()
        }
        
        print("[localization] restoreCameraState state:\(cameraState), isMainThread:\(Thread.isMainThread)")
        
        switch self.cameraState {
        case .preparing(let prev, _):
            switch prev {
            case .arkit(let context, _):
                self.cameraState = prev
                context.clearLast()
            default:
                break
            }
        default:
            break
        }
    }
    
    //MARK: display part
    private func setSafeState(_ state: HalfRealCameraState) {
        syncRoot.lock()
        cameraState = state
        syncRoot.unlock()
    }
    
    func displayStickers3D(viewModel: HalfRealTimeScene.GetStickers3D.ViewModel) {
        
        guard let cameraManager = self.cameraManager as? ArCameraManager else {
            return
        }
        
        let scene = viewModel.scene
        
        if self.cameraState.isArkit {
            let prev = self.cameraState
            self.cameraState = .preparing(prev: prev)
        }
        
        switch self.cameraState {
        case .preparing(let prev, _):
            switch prev {
            case .arkit(let context, _):
                
                /*guard context.cameraPoses.count == context.scenes.count + 1 else {
                    self.setSafeState(.arkit(context: context, prev: nil))
                    self.sticker3DRequest()
                    return
                }*/
                
                self.clearArContent(request: HalfRealTimeScene.ClearArContent.Request(cameraManager: cameraManager, clearAnchors: false))
                
                if let options = lastConfigOptions {
                    cameraManager.runArkitSession(options: options)
                    lastConfigOptions = nil
                }
                
                guard let arkitView = cameraManager.arKitSceneView else {
                    context.clear()
                    self.setSafeState(.arkit(context: context, prev: nil))
                    self.sticker3DRequest()
                    return
                }
                
                let prevMainNode = context.mainNode
                let prevScene = context.currentScene
                _ = context.put(scene: scene).put(arkitView: arkitView)
                
                // MARK: clear anchors
                
                for anchor in arkitView.session.currentFrame?.anchors ?? [] {
                    if !(anchor is ArCameraPoseAnchor) {
                        if (anchor is ArPointAnchor && prevMainNode == nil) || anchor is ArStickerAnchor || anchor is ARImageAnchor {
                            arkitView.session.remove(anchor: anchor)
                        }
                    }
                }
                
                // MARK: create AR scene
                
                let beforeAnimation = {
                    
                    // rebase to previos main node
                    
                    if let _ = context.getMainNode(), let previous = prevScene, context.anchorMode == .points {
                        let request = HalfRealTimeScene.MainNode.Request(prevScene: previous, context: context)
                        self.rebaseToLastAnchor(request: request)
                    }
                    
                    print("[anchor] s before animation")
                    if let cameraPose = arkitView.session.currentFrame?.camera.transform, let nodesData = context.calc2DNodes(cameraPose: cameraPose) {
                        
                        let request = HalfRealTimeScene.Nodes.Request(
                            maybeNodes: nodesData,
                            maybeStickers: scene.stickersData,
                            deviceOrientation: self.cameraManager.motionManager?.deviceOrientation()
                        )
                        
                        self.show2DMarkers(request: request)
                    }
                    self.setSafeState(.preparing(prev: prev, startAnimation: true))
                }
                
                context.showLastScene(updateScale: context.isAutoScale ? !context.lastScale.isLocal : false, isEnabled: arObjectsEnabled, animated: arAnimationDuration > 0, beforeAnimation: beforeAnimation) { res in
                    
                    print("[anchor] show scene, after animation, result:\(res)")
                    
                    guard res else {
                        self.setSafeState(.arkit(context: context, prev: nil))
                        self.sticker3DRequest()
                        return
                    }
                    
                    // MARK: set stickers pose to kfs selector
                    
                    if self.kfsSelectorEnabled && (context.lastScale.isLocal || !context.isAutoScale), let lastPose = context.lastPose {
                        self.updateKfsStickesPose(cameraPose: lastPose)
                    }
                    
                    // MARK: anchors
                    
                    let request = HalfRealTimeScene.HandleAnchors.Request(cameraManager: cameraManager, context: context, scene: scene)
                    self.handleAnchors(request: request)
                    
                    
                    self.setSafeState(.arkit(context: context, prev: nil))
                    self.sticker3DRequest()
                    
                    //TODO: filter video stickers
                    //if let isVideoFilter = UserDefaults.objectFilter?[StickerFilter.video.title], isVideoFilter {
                        DispatchQueue.main.async {
                            let request = HalfRealTimeScene.VideoSticker.Request(context: context, arkitView: arkitView)
                            self.handleVideoSticker(request: request)
                        }
                    //}
                    
                }
            default:
                self.sticker3DRequest()
                print("[anchor] invalid prev state:\(prev)")
                return
            }
        default:
            self.sticker3DRequest()
            print("[anchor] invalid state:\(cameraState)")
            break
        }
    }
    
    
    func displayArSessionRun(viewModel: HalfRealTimeScene.ArSessionRun.ViewModel) {
        
        print("[loc] * lock displayArSessionRun")
        syncRoot.lock()
        
        defer {
            syncRoot.unlock()
            print("[loc] * unlock displayArSessionRun")
        }
        
        lastConfigOptions = viewModel.options
        
    }
    

    
    private func updateKfsStickesPose(cameraPose: simd_float4x4) {
        guard let scene = cameraState.arContext?.currentScene else {
            return
        }
        
        var stickerPoses: [simd_float4x4] = []
        
        for (_, items) in scene.arfNodes {
            if items.count == 0 {
                continue
            }
            
            var center = simd_float3(0, 0, 0)
            for item in items {
                center += item.simdWorldPosition
            }
            
            center = center / Float(items.count)
            let pose = simd_float4x4(rotation: items[0].simdWorldTransform.upperLeft3x3, position: center)
            stickerPoses.append(pose)
        }
        
    }
    
    private func sticker3DRequest(deadline: Double = requestDeadline, force: Bool = false) {
        if (kfsSelectorEnabled && !stopKFS) || force {
            
            print("[loc] start task for sticker3DRequest")
            
            DispatchQueue.main.asyncAfter(deadline: .now() + deadline) {
                guard let posePixelBuffer = self.cameraState.arContext?.posePixelBuffer else {
                    print("[loc] pixelBuffer not ready")
                    self.sticker3DRequest(deadline: deadline, force: force)
                    return
                }
                
                DispatchQueue.global().async {
                    let viewModel = HalfRealTimeScene.FrameSelector.ViewModel(posePixelBuffer: posePixelBuffer)
                    self.displayFrameSelector(viewModel: viewModel)
                }
            }
        }
    }
    
    private func createCameraPosesAnchors() {
        guard let context = cameraState.arContext, let cameraManager = self.cameraManager as? ArCameraManager else {
            return
        }
        
        // remove anchors
        for anchor in cameraManager.arKitSceneView?.session.currentFrame?.anchors ?? [] {
            if anchor is ArCameraPoseAnchor {
                cameraManager.arKitSceneView?.session.remove(anchor: anchor)
            }
        }
        
        // add anchor on camera pose
        for pose in context.cameraPoses.suffix(10) {
            if  cameraManager.arKitSceneView?.session.currentFrame?.anchors.first(where: {$0.name == pose.id}) == nil {
                let anchor = ArCameraPoseAnchor(name: pose.id, transform: pose.pose)
                cameraManager.arKitSceneView?.session.add(anchor: anchor)
            }
        }
    }
    
    func displayFrameSelector(viewModel: HalfRealTimeScene.FrameSelector.ViewModel) {
        print("[loc] * lock displayKfsFrameSelector")
        syncRoot.lock()
        
        defer {
            syncRoot.unlock()
            print("[loc] * unlock displayKfsFrameSelector")
        }
        
        print("[loc] displayKfsFrameSelector, isMainThread:\(Thread.isMainThread)")
        
        guard let cameraManager = self.cameraManager as? ArCameraManager else {
            self.sticker3DRequest()
            return
        }
        
        switch cameraState {
        case .arkit(let context, _):
            let prev = self.cameraState
            self.cameraState = .preparing(prev: prev)
            let posePixelBuffer = viewModel.posePixelBuffer
            
            let result = cameraManager.prepareImage(pixelBuffer: posePixelBuffer.image)
            
            guard let dataImage = result.data else {
                self.cameraState = prev
                self.sticker3DRequest()
                return
            }
            
            _ = context.put(pose: posePixelBuffer.cameraPose, id: posePixelBuffer.id)
            self.createCameraPosesAnchors()
            
            let fileName = "\(ImageModels.ImageSource.PhotoCamera.rawValue)1.jpg"
            let imageInfo = ImageModels.Image(data: dataImage, filename: fileName, size: UIImage(data: dataImage)!.size)
            
            if let arkitView = cameraManager.arKitSceneView,
               let intrinsics = arkitView.session.currentFrame?.camera.intrinsics,
               let transform = arkitView.session.currentFrame?.camera.transform {
                
                let qw = sqrt(1 + transform.columns.0.x + transform.columns.1.y + transform.columns.2.z) / 2.0
                let qx = (transform.columns.2.y - transform.columns.1.z) / (qw * 4.0)
                let qy = (transform.columns.0.z - transform.columns.2.x) / (qw * 4.0)
                let qz = (transform.columns.1.x - transform.columns.0.y) / (qw * 4.0)
                
                let orientation = Quaternion(w: qw, x: qx, y: qy, z: qz)
                let position = Vector3d(x: transform.columns.3.x, y: transform.columns.3.y, z: transform.columns.3.z)
                let pose = Pose(position: position, orientation: orientation)
                
                let request = HalfRealTimeScene.Localize.Request(image: imageInfo, intrinsics: intrinsics, cameraPose: pose)
                self.localize(request: request)
            }
            
        default:
            break
        }
    }
    
    
    //MARK: presenter part
    // MARK: Private
    
    private func setRestartArSessionState(_ state: RestartArSessionState?) {
        if Thread.isMainThread {
            self.restartArSessionState = state
        } else {
            DispatchQueue.main.async {
                self.restartArSessionState = state
            }
        }
    }
    
    private func isLocalizeError(_ error: Error?) -> Bool {
        guard let respError = error as? FetchStickersError else {
            return false
        }
        
        switch respError {
        case .serverError(let code, _):
            return code == 1
        default:
            return false
        }
    }
    
    func presentStickers3D(response: HalfRealTimeScene.GetStickers3D.Response) {
        guard let scene = response.scene, response.error == nil else {
            var status: String = ""
            var errorCode = 0
            errorsInRow += 1
            
            if let error = response.error as? FetchStickersError, let code = error.code, code > 1 {
                status = error.message ?? "Fetch sticker 3D Error"
                errorCode = code
            }
            
            if response.scene == nil {
                status = "NO 3D stickers"
            }
            
            print("[loc] sticker3D, error:\(response.error), code:\(errorCode), isMainThread:\(Thread.isMainThread)")
            
            if errorCode != 0 {
                let alert = AlertMessage(title: "Error code = \(errorCode)", message: status)
                print(alert)
            } else {
                
                if isLocalizeError(response.error), let restartState = restartArSessionState {
                    let time = Date().timeIntervalSince1970 - restartState.time
                    
                    if time > goToStartScreenTime, restartState.isAnimation {
                        setRestartArSessionState(nil)
                    } else if time > animationTime, !restartState.isAnimation {
                        setRestartArSessionState(.animation(time: restartState.time))
                    }
                }
                
                self.restoreCameraState()
            }
            
            return
        }
        
        if let pos = scene.srvCamera?.position, length(pos) < 0.01 {
            print("[loc] sticker3D, length(pos) < 0.01")
            errorsInRow += 1
            return
        }
        
        print("[loc] displayStickers3D, isMainThread:\(Thread.isMainThread)")
        errorsInRow = 0
        setRestartArSessionState(nil)
        
        let viewModel = HalfRealTimeScene.GetStickers3D.ViewModel(scene: scene)
        self.displayStickers3D(viewModel: viewModel)
    }
    
    func presentMarkers2DMovable(response: HalfRealTimeScene.Markers2DMovable.Response) {
        let viewModel = HalfRealTimeScene.Markers2DMovable.ViewModel(nearObjectsPins: response.nearObjectsPins)
        //MARK: TODO - side pin markers
        //displayMarkers2DMovable(viewModel: viewModel)
    }
    
    private func getArkitStateColor(state: ARCamera.TrackingState) -> UIColor {
        var color = UIColor.black
        
        switch state {
        case .notAvailable:
            color = .red
        /** Tracking is limited. See tracking reason for details. */
        case .limited(let reason):
            switch reason {
            case .insufficientFeatures:
                color = .yellow
            default:
                color = .gray
            }
        /** Tracking is normal. */
        case .normal:
            break
        }
        return color
    }
    
    private func getArkitStateMessage(state: ARCamera.TrackingState) -> String {
        var message = "normal"
        
        switch state {
        case .notAvailable:
            message = "not available"
        /** Tracking is limited. See tracking reason for details. */
        case .limited(let reason):
            switch reason {
            case .excessiveMotion:
                message = "motion"
            case .initializing:
                message = "initializing"
            case .insufficientFeatures:
                message = "insufficient features"
            case .relocalizing:
                message = "relocalizing"
            default:
                message = "unknown"
            }
        /** Tracking is normal. */
        case .normal:
            break
        }
        return message
    }
    
    private func getCameraStatus(state: HalfRealCameraState) -> String {
        switch state {
        case .arkit:
            return "SCAN"
        case .preparing:
            return "REQV(\(errorsInRow))"
        default:
            return ""
        }
    }
    
    private func getScaleType(state: HalfRealCameraState) -> String {
        if let context = state.arContext {
            switch context.lastScale {
            case .none:
                return "S:-"
                     case .default:
                return "S:def"
            case .server:
                return "S:srv"
            case .usePoses:
                return "S:poses"
            case .arkit:
                return "S:arkit"
            }
        } else {
            return ""
        }
    }
    
    func presentArSessionStatus(response: HalfRealTimeScene.ArSessionStatus.Response) {
        
        let message = self.getArkitStateMessage(state: response.trackingState)
        var color = self.getArkitStateColor(state: response.trackingState)
        let cameraStatus = getCameraStatus(state: response.state)
        let scaleState = getScaleType(state: response.state)
        
        switch response.factor {
            case .degradated:
                color = .red
            case .normal:
                break
        }
        
        let status = String(format: "\(cameraStatus) \(message), \(scaleState)")
        let viewModel = HalfRealTimeScene.ArSessionStatus.ViewModel(status: status, color: color)
        //viewController?.displayArSessionStatus(viewModel: viewModel)
    }
    
    func presentArTrackingState(response: HalfRealTimeScene.ArTrackingState.Response) {
        let message = self.getArkitStateMessage(state: response.trackingState)
        let color = self.getArkitStateColor(state: response.trackingState)
        let cameraStatus = getCameraStatus(state: response.state)
        let scaleState = getScaleType(state: response.state)
        let viewModel = HalfRealTimeScene.ArSessionStatus.ViewModel(status: "\(cameraStatus) \(message) \(scaleState)", color: color)
        //viewController?.displayArSessionStatus(viewModel: viewModel)
    }
    
    func presentArSessionRun(response: HalfRealTimeScene.ArSessionRun.Response) {
        if restartArSessionState == nil {
            setRestartArSessionState(.start(time: Date().timeIntervalSince1970))
        }
        let viewModel = HalfRealTimeScene.ArSessionRun.ViewModel(options: response.options)
        self.displayArSessionRun(viewModel: viewModel)
    }
    
    func presentKfsFrameSelector(response: HalfRealTimeScene.FrameSelector.Response) {
        let viewModel = HalfRealTimeScene.FrameSelector.ViewModel(posePixelBuffer: response.posePixelBuffer)
        
        /*if Thread.isMainThread {
            DispatchQueue.global().async { [weak self] in
                self?.viewController?.displayKfsFrameSelector(viewModel: viewModel)
            }
        } else {
            viewController?.displayKfsFrameSelector(viewModel: viewModel)
        }*/
        
        self.displayFrameSelector(viewModel: viewModel)
    }
    
    func presentFrameSelector(response: HalfRealTimeScene.FrameSelector.Response) {
        let viewModel = HalfRealTimeScene.FrameSelector.ViewModel(posePixelBuffer: response.posePixelBuffer)
        self.displayFrameSelector(viewModel: viewModel)
    }
    
    func presentARObjects(response: HalfRealTimeScene.ARObjects.Response) {
        let result = response.localizationResult
        
        // MARK: Localize Error
        
        if result.status.code == ._1 {
            if let restartState = restartArSessionState {
                let time = Date().timeIntervalSince1970 - restartState.time
                
                if time > goToStartScreenTime, restartState.isAnimation {
                    setRestartArSessionState(nil)
                } else if time > animationTime, !restartState.isAnimation {
                    setRestartArSessionState(.animation(time: restartState.time))
                }
            }
        
            self.restoreCameraState()
            return
        }
        
        // MARK: No camera pose
        
        guard let pose = result.camera?.pose else {
            let error = FetchStickersError.serverError(code: HalfRealTimeScene.LocalizeError.Code.noPose.rawValue, message: "No camera pose")
            print(error)
            return
        }
        
        // MARK: No placeholders
        
        guard let placeholders = result.placeholders else {
            let error = FetchStickersError.serverError(code: HalfRealTimeScene.LocalizeError.Code.noPlaceholders.rawValue, message: "No placeholders")
            print(error)
            return
        }
        
        guard let objects = result.objects else {
            let error = FetchStickersError.serverError(code: HalfRealTimeScene.LocalizeError.Code.noObjects.rawValue, message: "No objects")
            print(error)
            return
        }
        
        let nodes = placeholders.map { Node3D.create(from: $0) }
        let serverCamera = ServerCamera.create(from: pose)
        let objectsInfo = objects.map { StickerModels.StickerData(id: $0.placeholder.placeholderId.hashValue, options: StickerOptions.sharedInstance.parse(sticker: $0.sticker)) }
        
        errorsInRow = 0
        setRestartArSessionState(nil)
        
        let scene = Scene3D(reconstructionId: result.reconstructionId, nodes: nodes, srvCamera: serverCamera, stickersData: objectsInfo)
        let viewModel = HalfRealTimeScene.GetStickers3D.ViewModel(scene: scene)
        self.displayStickers3D(viewModel: viewModel)

    }
    
}

extension HalfRealTimeSceneInteractor: ArCameraManagerDelegate {
    
    func arCameraManager(didUpdateLocation updateLocation: CLLocation) {
        guard kfsSelectorEnabled, let arkitView = (cameraManager as? ArCameraManager)?.arKitSceneView, let camera = arkitView.session.currentFrame?.camera else {
            return
        }
        
        let request = HalfRealTimeScene.UpdateLocation.Request(location: updateLocation, cameraPosition: camera.transform.position, trackingState: camera.trackingState, state: cameraState)
        self.arCameraUpdateLocation(request: request)
    }
    
    func arCameraManager(didUpdateMotion deviceMotion: CMDeviceMotion) {
        guard kfsSelectorEnabled, let arkitView = (cameraManager as? ArCameraManager)?.arKitSceneView, let camera = arkitView.session.currentFrame?.camera else {
            return
        }
        
        let request = HalfRealTimeScene.UpdateDeviceMotion.Request(deviceMotion: deviceMotion, cameraPosition: camera.transform.position, trackingState: camera.trackingState, state: cameraState)
        self.arCameraUpdateDeviceMotion(request: request)
    }
    
    func arCameraManager(didActivityUpdate activity: CMMotionActivity) {
        
    }
    
    func arCameraManager(didFrameUpdate frame: ARFrame, for session: ARSession) {
        if let context = self.cameraState.arContext {
            switch self.cameraState {
            case .arkit, .preparing:
                
                // move 2d sticker
                
                if let nodesData = context.calc2DNodes(cameraPose: frame.camera.transform, ignoreVisibility: false) {
                    let orientation = self.cameraManager.motionManager?.deviceOrientation()
                    
                    let request = HalfRealTimeScene.Markers2DMovable.Request(maybeNodes: nodesData, deviceOrientation: orientation, context: context, cameraPose: frame.camera.transform)
                    self.move2DMarkers(request: request)
                } else {
                    let orientation = self.cameraManager.motionManager?.deviceOrientation()
                    
                    let request = HalfRealTimeScene.Markers2DMovable.Request(maybeNodes: nil, deviceOrientation: orientation, context: context, cameraPose: frame.camera.transform)
                    self.move2DMarkers(request: request)
                }
                
                // add traces
                if UserDefaults.arTraces ?? false {
                    self.updateArTrace(arkitView: nil, cameraPose: frame.camera.transform, cameraAngles: frame.camera.eulerAngles)
                }
                
                // put pixel buffer to context & call kfs selector
                
                switch frame.camera.trackingState {
                case .normal:
                    let buffer = PixelBufferWithPose(id: UUID().uuidString, image: frame.capturedImage, cameraPose: frame.camera.transform)
                    _ = context.put(posePixelBuffer: buffer)
                    
                    if !stopKFS && kfsSelectorEnabled {
                        timerSelectorRequest(posePixelBuffer: buffer, timerInterval: context.timerValue)
                    }
                default:
                    print("[localize] session not ready, state = \(frame.camera.trackingState)")
                    return
                }
                
            default:
                break
            }
        }
    }
    
    func arCameraManager(didUpdateSessionState state: ARCamera.TrackingState) {
        let request = HalfRealTimeScene.ArTrackingState.Request(trackingState: state, state: cameraState)
        self.updateArTrackingState(request: request)
    }
    
    // MARK: Anchors
    
    private func createPlaneNode(_ node: SCNNode, for anchor: ARAnchor) {
        
        guard let cameraManager = self.cameraManager as? ArCameraManager, let sceneView = cameraManager.arKitSceneView, let planeAnchor = anchor as? ARPlaneAnchor else {
            return
        }
        
        guard let meshGeometry = ARSCNPlaneGeometry(device: sceneView.device!)
            else {
                fatalError("Can't create plane geometry")
        }
        
        let meshNode : SCNNode
        meshGeometry.update(from: planeAnchor.geometry)
        meshNode = SCNNode(geometry: meshGeometry)
        meshNode.opacity = 0.3
        meshNode.name = meshNodeName
        
        guard let material = meshNode.geometry?.firstMaterial
            else { fatalError("ARSCNPlaneGeometry always has one material") }
        material.diffuse.contents = UIColor.green
        
        node.addChildNode(meshNode)
    }
    
    func arCameraManager(didAdd node: SCNNode, for anchor: ARAnchor) {
        
        if showArPlane {
            createPlaneNode(node, for: anchor)
        }
        
        switch self.cameraState {
        case .arkit(let context, _):
            let request = HalfRealTimeScene.AnchorAction.Request(node: node, anchor: anchor, context: context)
            self.createAnchor(request: request)
        default:
            break
        }
    }
    
    func arCameraManager(didUpdate node: SCNNode, for anchor: ARAnchor) {
        
        if showArPlane, let planeAnchor = anchor as? ARPlaneAnchor {
            if let planeGeometry = node.childNode(withName: meshNodeName, recursively: false)!.geometry as? ARSCNPlaneGeometry {
                planeGeometry.update(from: planeAnchor.geometry)
            }
        }
        
        if let context = cameraState.arContext {
            let request = HalfRealTimeScene.AnchorAction.Request(node: node, anchor: anchor, context: context)
            self.updateAnchor(request: request)
        }
    }
}
